{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport Metadata from './metadata';\nimport PhoneNumber from './PhoneNumber';\nimport AsYouTypeState from './AsYouTypeState';\nimport AsYouTypeFormatter, { DIGIT_PLACEHOLDER } from './AsYouTypeFormatter';\nimport AsYouTypeParser, { extractFormattedDigitsAndPlus } from './AsYouTypeParser';\nimport getCountryByCallingCode from './helpers/getCountryByCallingCode';\nvar USE_NON_GEOGRAPHIC_COUNTRY_CODE = false;\n\nvar AsYouType = /*#__PURE__*/function () {\n  /**\r\n   * @param {(string|object)?} [optionsOrDefaultCountry] - The default country used for parsing non-international phone numbers. Can also be an `options` object.\r\n   * @param {Object} metadata\r\n   */\n  function AsYouType(optionsOrDefaultCountry, metadata) {\n    _classCallCheck(this, AsYouType);\n\n    this.metadata = new Metadata(metadata);\n\n    var _this$getCountryAndCa = this.getCountryAndCallingCode(optionsOrDefaultCountry),\n        _this$getCountryAndCa2 = _slicedToArray(_this$getCountryAndCa, 2),\n        defaultCountry = _this$getCountryAndCa2[0],\n        defaultCallingCode = _this$getCountryAndCa2[1];\n\n    this.defaultCountry = defaultCountry;\n    this.defaultCallingCode = defaultCallingCode;\n    this.reset();\n  }\n\n  _createClass(AsYouType, [{\n    key: \"getCountryAndCallingCode\",\n    value: function getCountryAndCallingCode(optionsOrDefaultCountry) {\n      // Set `defaultCountry` and `defaultCallingCode` options.\n      var defaultCountry;\n      var defaultCallingCode; // Turns out `null` also has type \"object\". Weird.\n\n      if (optionsOrDefaultCountry) {\n        if (_typeof(optionsOrDefaultCountry) === 'object') {\n          defaultCountry = optionsOrDefaultCountry.defaultCountry;\n          defaultCallingCode = optionsOrDefaultCountry.defaultCallingCode;\n        } else {\n          defaultCountry = optionsOrDefaultCountry;\n        }\n      }\n\n      if (defaultCountry && !this.metadata.hasCountry(defaultCountry)) {\n        defaultCountry = undefined;\n      }\n\n      if (defaultCallingCode) {\n        /* istanbul ignore if */\n        if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\n          if (this.metadata.isNonGeographicCallingCode(defaultCallingCode)) {\n            defaultCountry = '001';\n          }\n        }\n      }\n\n      return [defaultCountry, defaultCallingCode];\n    }\n    /**\r\n     * Inputs \"next\" phone number characters.\r\n     * @param  {string} text\r\n     * @return {string} Formatted phone number characters that have been input so far.\r\n     */\n\n  }, {\n    key: \"input\",\n    value: function input(text) {\n      var _this$parser$input = this.parser.input(text, this.state),\n          digits = _this$parser$input.digits,\n          justLeadingPlus = _this$parser$input.justLeadingPlus;\n\n      if (justLeadingPlus) {\n        this.formattedOutput = '+';\n      } else if (digits) {\n        this.determineTheCountryIfNeeded(); // Match the available formats by the currently available leading digits.\n\n        if (this.state.nationalSignificantNumber) {\n          this.formatter.narrowDownMatchingFormats(this.state);\n        }\n\n        var formattedNationalNumber;\n\n        if (this.metadata.hasSelectedNumberingPlan()) {\n          formattedNationalNumber = this.formatter.format(digits, this.state);\n        }\n\n        if (formattedNationalNumber === undefined) {\n          // See if another national (significant) number could be re-extracted.\n          if (this.parser.reExtractNationalSignificantNumber(this.state)) {\n            this.determineTheCountryIfNeeded(); // If it could, then re-try formatting the new national (significant) number.\n\n            var nationalDigits = this.state.getNationalDigits();\n\n            if (nationalDigits) {\n              formattedNationalNumber = this.formatter.format(nationalDigits, this.state);\n            }\n          }\n        }\n\n        this.formattedOutput = formattedNationalNumber ? this.getFullNumber(formattedNationalNumber) : this.getNonFormattedNumber();\n      }\n\n      return this.formattedOutput;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var _this = this;\n\n      this.state = new AsYouTypeState({\n        onCountryChange: function onCountryChange(country) {\n          // Before version `1.6.0`, the official `AsYouType` formatter API\n          // included the `.country` property of an `AsYouType` instance.\n          // Since that property (along with the others) have been moved to\n          // `this.state`, `this.country` property is emulated for compatibility\n          // with the old versions.\n          _this.country = country;\n        },\n        onCallingCodeChange: function onCallingCodeChange(country, callingCode) {\n          _this.metadata.selectNumberingPlan(country, callingCode);\n\n          _this.formatter.reset(_this.metadata.numberingPlan, _this.state);\n\n          _this.parser.reset(_this.metadata.numberingPlan);\n        }\n      });\n      this.formatter = new AsYouTypeFormatter({\n        state: this.state,\n        metadata: this.metadata\n      });\n      this.parser = new AsYouTypeParser({\n        defaultCountry: this.defaultCountry,\n        defaultCallingCode: this.defaultCallingCode,\n        metadata: this.metadata,\n        state: this.state,\n        onNationalSignificantNumberChange: function onNationalSignificantNumberChange() {\n          _this.determineTheCountryIfNeeded();\n\n          _this.formatter.reset(_this.metadata.numberingPlan, _this.state);\n        }\n      });\n      this.state.reset(this.defaultCountry, this.defaultCallingCode);\n      this.formattedOutput = '';\n      return this;\n    }\n    /**\r\n     * Returns `true` if the phone number is being input in international format.\r\n     * In other words, returns `true` if and only if the parsed phone number starts with a `\"+\"`.\r\n     * @return {boolean}\r\n     */\n\n  }, {\n    key: \"isInternational\",\n    value: function isInternational() {\n      return this.state.international;\n    }\n    /**\r\n     * Returns the \"country calling code\" part of the phone number.\r\n     * Returns `undefined` if the number is not being input in international format.\r\n     * Returns \"country calling code\" for \"non-geographic\" phone numbering plans too.\r\n     * @return {string} [callingCode]\r\n     */\n\n  }, {\n    key: \"getCallingCode\",\n    value: function getCallingCode() {\n      return this.state.callingCode;\n    } // A legacy alias.\n\n  }, {\n    key: \"getCountryCallingCode\",\n    value: function getCountryCallingCode() {\n      return this.getCallingCode();\n    }\n    /**\r\n     * Returns a two-letter country code of the phone number.\r\n     * Returns `undefined` for \"non-geographic\" phone numbering plans.\r\n     * Returns `undefined` if no phone number has been input yet.\r\n     * @return {string} [country]\r\n     */\n\n  }, {\n    key: \"getCountry\",\n    value: function getCountry() {\n      var _this$state = this.state,\n          digits = _this$state.digits,\n          country = _this$state.country; // If no digits have been input yet,\n      // then `this.country` is the `defaultCountry`.\n      // Won't return the `defaultCountry` in such case.\n\n      if (!digits) {\n        return;\n      }\n\n      var countryCode = country;\n      /* istanbul ignore if */\n\n      if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\n        // `AsYouType.getCountry()` returns `undefined`\n        // for \"non-geographic\" phone numbering plans.\n        if (countryCode === '001') {\n          countryCode = undefined;\n        }\n      }\n\n      return countryCode;\n    }\n  }, {\n    key: \"determineTheCountryIfNeeded\",\n    value: function determineTheCountryIfNeeded() {\n      // Suppose a user enters a phone number in international format,\n      // and there're several countries corresponding to that country calling code,\n      // and a country has been derived from the number, and then\n      // a user enters one more digit and the number is no longer\n      // valid for the derived country, so the country should be re-derived\n      // on every new digit in those cases.\n      //\n      // If the phone number is being input in national format,\n      // then it could be a case when `defaultCountry` wasn't specified\n      // when creating `AsYouType` instance, and just `defaultCallingCode` was specified,\n      // and that \"calling code\" could correspond to a \"non-geographic entity\",\n      // or there could be several countries corresponding to that country calling code.\n      // In those cases, `this.country` is `undefined` and should be derived\n      // from the number. Again, if country calling code is ambiguous, then\n      // `this.country` should be re-derived with each new digit.\n      //\n      if (!this.state.country || this.isCountryCallingCodeAmbiguous()) {\n        this.determineTheCountry();\n      }\n    } // Prepends `+CountryCode ` in case of an international phone number\n\n  }, {\n    key: \"getFullNumber\",\n    value: function getFullNumber(formattedNationalNumber) {\n      var _this2 = this;\n\n      if (this.isInternational()) {\n        var prefix = function prefix(text) {\n          return _this2.formatter.getInternationalPrefixBeforeCountryCallingCode(_this2.state, {\n            spacing: text ? true : false\n          }) + text;\n        };\n\n        var callingCode = this.state.callingCode;\n\n        if (!callingCode) {\n          return prefix(\"\".concat(this.state.getDigitsWithoutInternationalPrefix()));\n        }\n\n        if (!formattedNationalNumber) {\n          return prefix(callingCode);\n        }\n\n        return prefix(\"\".concat(callingCode, \" \").concat(formattedNationalNumber));\n      }\n\n      return formattedNationalNumber;\n    }\n  }, {\n    key: \"getNonFormattedNationalNumberWithPrefix\",\n    value: function getNonFormattedNationalNumberWithPrefix() {\n      var _this$state2 = this.state,\n          nationalSignificantNumber = _this$state2.nationalSignificantNumber,\n          complexPrefixBeforeNationalSignificantNumber = _this$state2.complexPrefixBeforeNationalSignificantNumber,\n          nationalPrefix = _this$state2.nationalPrefix;\n      var number = nationalSignificantNumber;\n      var prefix = complexPrefixBeforeNationalSignificantNumber || nationalPrefix;\n\n      if (prefix) {\n        number = prefix + number;\n      }\n\n      return number;\n    }\n  }, {\n    key: \"getNonFormattedNumber\",\n    value: function getNonFormattedNumber() {\n      var nationalSignificantNumberMatchesInput = this.state.nationalSignificantNumberMatchesInput;\n      return this.getFullNumber(nationalSignificantNumberMatchesInput ? this.getNonFormattedNationalNumberWithPrefix() : this.state.getNationalDigits());\n    }\n  }, {\n    key: \"getNonFormattedTemplate\",\n    value: function getNonFormattedTemplate() {\n      var number = this.getNonFormattedNumber();\n\n      if (number) {\n        return number.replace(/[\\+\\d]/g, DIGIT_PLACEHOLDER);\n      }\n    }\n  }, {\n    key: \"isCountryCallingCodeAmbiguous\",\n    value: function isCountryCallingCodeAmbiguous() {\n      var callingCode = this.state.callingCode;\n      var countryCodes = this.metadata.getCountryCodesForCallingCode(callingCode);\n      return countryCodes && countryCodes.length > 1;\n    } // Determines the country of the phone number\n    // entered so far based on the country phone code\n    // and the national phone number.\n\n  }, {\n    key: \"determineTheCountry\",\n    value: function determineTheCountry() {\n      this.state.setCountry(getCountryByCallingCode(this.isInternational() ? this.state.callingCode : this.defaultCallingCode, this.state.nationalSignificantNumber, this.metadata));\n    }\n    /**\r\n     * Returns an instance of `PhoneNumber` class.\r\n     * Will return `undefined` if no national (significant) number\r\n     * digits have been entered so far, or if no `defaultCountry` has been\r\n     * set and the user enters a phone number not in international format.\r\n     */\n\n  }, {\n    key: \"getNumber\",\n    value: function getNumber() {\n      var _this$state3 = this.state,\n          nationalSignificantNumber = _this$state3.nationalSignificantNumber,\n          carrierCode = _this$state3.carrierCode;\n\n      if (this.isInternational()) {\n        if (!this.state.callingCode) {\n          return;\n        }\n      } else {\n        if (!this.state.country && !this.defaultCallingCode) {\n          return;\n        }\n      }\n\n      if (!nationalSignificantNumber) {\n        return;\n      }\n\n      var countryCode = this.getCountry();\n      var callingCode = this.getCountryCallingCode() || this.defaultCallingCode;\n      var phoneNumber = new PhoneNumber(countryCode || callingCode, nationalSignificantNumber, this.metadata.metadata);\n\n      if (carrierCode) {\n        phoneNumber.carrierCode = carrierCode;\n      } // Phone number extensions are not supported by \"As You Type\" formatter.\n\n\n      return phoneNumber;\n    }\n    /**\r\n     * Returns `true` if the phone number is \"possible\".\r\n     * Is just a shortcut for `PhoneNumber.isPossible()`.\r\n     * @return {boolean}\r\n     */\n\n  }, {\n    key: \"isPossible\",\n    value: function isPossible() {\n      var phoneNumber = this.getNumber();\n\n      if (!phoneNumber) {\n        return false;\n      }\n\n      return phoneNumber.isPossible();\n    }\n    /**\r\n     * Returns `true` if the phone number is \"valid\".\r\n     * Is just a shortcut for `PhoneNumber.isValid()`.\r\n     * @return {boolean}\r\n     */\n\n  }, {\n    key: \"isValid\",\n    value: function isValid() {\n      var phoneNumber = this.getNumber();\n\n      if (!phoneNumber) {\n        return false;\n      }\n\n      return phoneNumber.isValid();\n    }\n    /**\r\n     * @deprecated\r\n     * This method is used in `react-phone-number-input/source/input-control.js`\r\n     * in versions before `3.0.16`.\r\n     */\n\n  }, {\n    key: \"getNationalNumber\",\n    value: function getNationalNumber() {\n      return this.state.nationalSignificantNumber;\n    }\n    /**\r\n     * Returns the phone number characters entered by the user.\r\n     * @return {string}\r\n     */\n\n  }, {\n    key: \"getChars\",\n    value: function getChars() {\n      return (this.state.international ? '+' : '') + this.state.digits;\n    }\n    /**\r\n     * Returns the template for the formatted phone number.\r\n     * @return {string}\r\n     */\n\n  }, {\n    key: \"getTemplate\",\n    value: function getTemplate() {\n      return this.formatter.getTemplate(this.state) || this.getNonFormattedTemplate() || '';\n    }\n  }]);\n\n  return AsYouType;\n}();\n\nexport { AsYouType as default };","map":{"version":3,"sources":["../source/AsYouType.js"],"names":["USE_NON_GEOGRAPHIC_COUNTRY_CODE","AsYouType","defaultCountry","defaultCallingCode","optionsOrDefaultCountry","text","digits","justLeadingPlus","formattedNationalNumber","nationalDigits","onCountryChange","onCallingCodeChange","state","metadata","onNationalSignificantNumberChange","country","countryCode","prefix","spacing","callingCode","nationalSignificantNumber","complexPrefixBeforeNationalSignificantNumber","nationalPrefix","number","nationalSignificantNumberMatchesInput","countryCodes","getCountryByCallingCode","carrierCode","phoneNumber"],"mappings":"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","sourcesContent":["import Metadata from './metadata'\r\nimport PhoneNumber from './PhoneNumber'\r\nimport AsYouTypeState from './AsYouTypeState'\r\nimport AsYouTypeFormatter, { DIGIT_PLACEHOLDER } from './AsYouTypeFormatter'\r\nimport AsYouTypeParser, { extractFormattedDigitsAndPlus } from './AsYouTypeParser'\r\nimport getCountryByCallingCode from './helpers/getCountryByCallingCode'\r\n\r\nconst USE_NON_GEOGRAPHIC_COUNTRY_CODE = false\r\n\r\nexport default class AsYouType {\r\n\t/**\r\n\t * @param {(string|object)?} [optionsOrDefaultCountry] - The default country used for parsing non-international phone numbers. Can also be an `options` object.\r\n\t * @param {Object} metadata\r\n\t */\r\n\tconstructor(optionsOrDefaultCountry, metadata) {\r\n\t\tthis.metadata = new Metadata(metadata)\r\n\t\tconst [defaultCountry, defaultCallingCode] = this.getCountryAndCallingCode(optionsOrDefaultCountry)\r\n\t\tthis.defaultCountry = defaultCountry\r\n\t\tthis.defaultCallingCode = defaultCallingCode\r\n\t\tthis.reset()\r\n\t}\r\n\r\n\tgetCountryAndCallingCode(optionsOrDefaultCountry) {\r\n\t\t// Set `defaultCountry` and `defaultCallingCode` options.\r\n\t\tlet defaultCountry\r\n\t\tlet defaultCallingCode\r\n\t\t// Turns out `null` also has type \"object\". Weird.\r\n\t\tif (optionsOrDefaultCountry) {\r\n\t\t\tif (typeof optionsOrDefaultCountry === 'object') {\r\n\t\t\t\tdefaultCountry = optionsOrDefaultCountry.defaultCountry\r\n\t\t\t\tdefaultCallingCode = optionsOrDefaultCountry.defaultCallingCode\r\n\t\t\t} else {\r\n\t\t\t\tdefaultCountry = optionsOrDefaultCountry\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (defaultCountry && !this.metadata.hasCountry(defaultCountry)) {\r\n\t\t\tdefaultCountry = undefined\r\n\t\t}\r\n\t\tif (defaultCallingCode) {\r\n\t\t\t/* istanbul ignore if */\r\n\t\t\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\t\t\tif (this.metadata.isNonGeographicCallingCode(defaultCallingCode)) {\r\n\t\t\t\t\tdefaultCountry = '001'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn [defaultCountry, defaultCallingCode]\r\n\t}\r\n\r\n\t/**\r\n\t * Inputs \"next\" phone number characters.\r\n\t * @param  {string} text\r\n\t * @return {string} Formatted phone number characters that have been input so far.\r\n\t */\r\n\tinput(text) {\r\n\t\tconst {\r\n\t\t\tdigits,\r\n\t\t\tjustLeadingPlus\r\n\t\t} = this.parser.input(text, this.state)\r\n\t\tif (justLeadingPlus) {\r\n\t\t\tthis.formattedOutput = '+'\r\n\t\t} else if (digits) {\r\n\t\t\tthis.determineTheCountryIfNeeded()\r\n\t\t\t// Match the available formats by the currently available leading digits.\r\n\t\t\tif (this.state.nationalSignificantNumber) {\r\n\t\t\t\tthis.formatter.narrowDownMatchingFormats(this.state)\r\n\t\t\t}\r\n\t\t\tlet formattedNationalNumber\r\n\t\t\tif (this.metadata.hasSelectedNumberingPlan()) {\r\n\t\t\t\tformattedNationalNumber = this.formatter.format(digits, this.state)\r\n\t\t\t}\r\n\t\t\tif (formattedNationalNumber === undefined) {\r\n\t\t\t\t// See if another national (significant) number could be re-extracted.\r\n\t\t\t\tif (this.parser.reExtractNationalSignificantNumber(this.state)) {\r\n\t\t\t\t\tthis.determineTheCountryIfNeeded()\r\n\t\t\t\t\t// If it could, then re-try formatting the new national (significant) number.\r\n\t\t\t\t\tconst nationalDigits = this.state.getNationalDigits()\r\n\t\t\t\t\tif (nationalDigits) {\r\n\t\t\t\t\t\tformattedNationalNumber = this.formatter.format(nationalDigits, this.state)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.formattedOutput = formattedNationalNumber\r\n\t\t\t\t? this.getFullNumber(formattedNationalNumber)\r\n\t\t\t\t: this.getNonFormattedNumber()\r\n\t\t}\r\n\t\treturn this.formattedOutput\r\n\t}\r\n\r\n\treset() {\r\n\t\tthis.state = new AsYouTypeState({\r\n\t\t\tonCountryChange: (country) => {\r\n\t\t\t\t// Before version `1.6.0`, the official `AsYouType` formatter API\r\n\t\t\t\t// included the `.country` property of an `AsYouType` instance.\r\n\t\t\t\t// Since that property (along with the others) have been moved to\r\n\t\t\t\t// `this.state`, `this.country` property is emulated for compatibility\r\n\t\t\t\t// with the old versions.\r\n\t\t\t\tthis.country = country\r\n\t\t\t},\r\n\t\t\tonCallingCodeChange: (country, callingCode) => {\r\n\t\t\t\tthis.metadata.selectNumberingPlan(country, callingCode)\r\n\t\t\t\tthis.formatter.reset(this.metadata.numberingPlan, this.state)\r\n\t\t\t\tthis.parser.reset(this.metadata.numberingPlan)\r\n\t\t\t}\r\n\t\t})\r\n\t\tthis.formatter = new AsYouTypeFormatter({\r\n\t\t\tstate: this.state,\r\n\t\t\tmetadata: this.metadata\r\n\t\t})\r\n\t\tthis.parser = new AsYouTypeParser({\r\n\t\t\tdefaultCountry: this.defaultCountry,\r\n\t\t\tdefaultCallingCode: this.defaultCallingCode,\r\n\t\t\tmetadata: this.metadata,\r\n\t\t\tstate: this.state,\r\n\t\t\tonNationalSignificantNumberChange: () => {\r\n\t\t\t\tthis.determineTheCountryIfNeeded()\r\n\t\t\t\tthis.formatter.reset(this.metadata.numberingPlan, this.state)\r\n\t\t\t}\r\n\t\t})\r\n\t\tthis.state.reset(this.defaultCountry, this.defaultCallingCode)\r\n\t\tthis.formattedOutput = ''\r\n\t\treturn this\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if the phone number is being input in international format.\r\n\t * In other words, returns `true` if and only if the parsed phone number starts with a `\"+\"`.\r\n\t * @return {boolean}\r\n\t */\r\n\tisInternational() {\r\n\t\treturn this.state.international\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the \"country calling code\" part of the phone number.\r\n\t * Returns `undefined` if the number is not being input in international format.\r\n\t * Returns \"country calling code\" for \"non-geographic\" phone numbering plans too.\r\n\t * @return {string} [callingCode]\r\n\t */\r\n\tgetCallingCode() {\r\n\t\treturn this.state.callingCode\r\n\t}\r\n\r\n\t// A legacy alias.\r\n\tgetCountryCallingCode() {\r\n\t\treturn this.getCallingCode()\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a two-letter country code of the phone number.\r\n\t * Returns `undefined` for \"non-geographic\" phone numbering plans.\r\n\t * Returns `undefined` if no phone number has been input yet.\r\n\t * @return {string} [country]\r\n\t */\r\n\tgetCountry() {\r\n\t\tconst { digits, country } = this.state\r\n\t\t// If no digits have been input yet,\r\n\t\t// then `this.country` is the `defaultCountry`.\r\n\t\t// Won't return the `defaultCountry` in such case.\r\n\t\tif (!digits) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tlet countryCode = country\r\n\t\t/* istanbul ignore if */\r\n\t\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\t\t// `AsYouType.getCountry()` returns `undefined`\r\n\t\t\t// for \"non-geographic\" phone numbering plans.\r\n\t\t\tif (countryCode === '001') {\r\n\t\t\t\tcountryCode = undefined\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn countryCode\r\n\t}\r\n\r\n\tdetermineTheCountryIfNeeded() {\r\n\t\t// Suppose a user enters a phone number in international format,\r\n\t\t// and there're several countries corresponding to that country calling code,\r\n\t\t// and a country has been derived from the number, and then\r\n\t\t// a user enters one more digit and the number is no longer\r\n\t\t// valid for the derived country, so the country should be re-derived\r\n\t\t// on every new digit in those cases.\r\n\t\t//\r\n\t\t// If the phone number is being input in national format,\r\n\t\t// then it could be a case when `defaultCountry` wasn't specified\r\n\t\t// when creating `AsYouType` instance, and just `defaultCallingCode` was specified,\r\n\t\t// and that \"calling code\" could correspond to a \"non-geographic entity\",\r\n\t\t// or there could be several countries corresponding to that country calling code.\r\n\t\t// In those cases, `this.country` is `undefined` and should be derived\r\n\t\t// from the number. Again, if country calling code is ambiguous, then\r\n\t\t// `this.country` should be re-derived with each new digit.\r\n\t\t//\r\n\t\tif (!this.state.country || this.isCountryCallingCodeAmbiguous()) {\r\n\t\t\tthis.determineTheCountry()\r\n\t\t}\r\n\t}\r\n\r\n\t// Prepends `+CountryCode ` in case of an international phone number\r\n\tgetFullNumber(formattedNationalNumber) {\r\n\t\tif (this.isInternational()) {\r\n\t\t\tconst prefix = (text) => this.formatter.getInternationalPrefixBeforeCountryCallingCode(this.state, {\r\n\t\t\t\tspacing: text ? true : false\r\n\t\t\t}) + text\r\n\t\t\tconst { callingCode } = this.state\r\n\t\t\tif (!callingCode) {\r\n\t\t\t\treturn prefix(`${this.state.getDigitsWithoutInternationalPrefix()}`)\r\n\t\t\t}\r\n\t\t\tif (!formattedNationalNumber) {\r\n\t\t\t\treturn prefix(callingCode)\r\n\t\t\t}\r\n\t\t\treturn prefix(`${callingCode} ${formattedNationalNumber}`)\r\n\t\t}\r\n\t\treturn formattedNationalNumber\r\n\t}\r\n\r\n\tgetNonFormattedNationalNumberWithPrefix() {\r\n\t\tconst {\r\n\t\t\tnationalSignificantNumber,\r\n\t\t\tcomplexPrefixBeforeNationalSignificantNumber,\r\n\t\t\tnationalPrefix\r\n\t\t} = this.state\r\n\t\tlet number = nationalSignificantNumber\r\n\t\tconst prefix = complexPrefixBeforeNationalSignificantNumber || nationalPrefix\r\n\t\tif (prefix) {\r\n\t\t\tnumber = prefix + number\r\n\t\t}\r\n\t\treturn number\r\n\t}\r\n\r\n\tgetNonFormattedNumber() {\r\n\t\tconst { nationalSignificantNumberMatchesInput } = this.state\r\n\t\treturn this.getFullNumber(\r\n\t\t\tnationalSignificantNumberMatchesInput\r\n\t\t\t\t? this.getNonFormattedNationalNumberWithPrefix()\r\n\t\t\t\t: this.state.getNationalDigits()\r\n\t\t)\r\n\t}\r\n\r\n\tgetNonFormattedTemplate() {\r\n\t\tconst number = this.getNonFormattedNumber()\r\n\t\tif (number) {\r\n\t\t\treturn number.replace(/[\\+\\d]/g, DIGIT_PLACEHOLDER)\r\n\t\t}\r\n\t}\r\n\r\n\tisCountryCallingCodeAmbiguous() {\r\n\t\tconst { callingCode } = this.state\r\n\t\tconst countryCodes = this.metadata.getCountryCodesForCallingCode(callingCode)\r\n\t\treturn countryCodes && countryCodes.length > 1\r\n\t}\r\n\r\n\t// Determines the country of the phone number\r\n\t// entered so far based on the country phone code\r\n\t// and the national phone number.\r\n\tdetermineTheCountry() {\r\n\t\tthis.state.setCountry(getCountryByCallingCode(\r\n\t\t\tthis.isInternational() ? this.state.callingCode : this.defaultCallingCode,\r\n\t\t\tthis.state.nationalSignificantNumber,\r\n\t\t\tthis.metadata\r\n\t\t))\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an instance of `PhoneNumber` class.\r\n\t * Will return `undefined` if no national (significant) number\r\n\t * digits have been entered so far, or if no `defaultCountry` has been\r\n\t * set and the user enters a phone number not in international format.\r\n\t */\r\n\tgetNumber() {\r\n\t\tlet {\r\n\t\t\tnationalSignificantNumber,\r\n\t\t\tcarrierCode\r\n\t\t} = this.state\r\n\t\tif (this.isInternational()) {\r\n\t\t\tif (!this.state.callingCode) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (!this.state.country && !this.defaultCallingCode) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!nationalSignificantNumber) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tconst countryCode = this.getCountry()\r\n\t\tconst callingCode = this.getCountryCallingCode() || this.defaultCallingCode\r\n\t\tconst phoneNumber = new PhoneNumber(\r\n\t\t\tcountryCode || callingCode,\r\n\t\t\tnationalSignificantNumber,\r\n\t\t\tthis.metadata.metadata\r\n\t\t)\r\n\t\tif (carrierCode) {\r\n\t\t\tphoneNumber.carrierCode = carrierCode\r\n\t\t}\r\n\t\t// Phone number extensions are not supported by \"As You Type\" formatter.\r\n\t\treturn phoneNumber\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if the phone number is \"possible\".\r\n\t * Is just a shortcut for `PhoneNumber.isPossible()`.\r\n\t * @return {boolean}\r\n\t */\r\n\tisPossible() {\r\n\t\tconst phoneNumber = this.getNumber()\r\n\t\tif (!phoneNumber) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\treturn phoneNumber.isPossible()\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if the phone number is \"valid\".\r\n\t * Is just a shortcut for `PhoneNumber.isValid()`.\r\n\t * @return {boolean}\r\n\t */\r\n\tisValid() {\r\n\t\tconst phoneNumber = this.getNumber()\r\n\t\tif (!phoneNumber) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\treturn phoneNumber.isValid()\r\n\t}\r\n\r\n\t/**\r\n\t * @deprecated\r\n\t * This method is used in `react-phone-number-input/source/input-control.js`\r\n\t * in versions before `3.0.16`.\r\n\t */\r\n\tgetNationalNumber() {\r\n\t\treturn this.state.nationalSignificantNumber\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the phone number characters entered by the user.\r\n\t * @return {string}\r\n\t */\r\n\tgetChars() {\r\n\t\treturn (this.state.international ? '+' : '') + this.state.digits\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the template for the formatted phone number.\r\n\t * @return {string}\r\n\t */\r\n\tgetTemplate() {\r\n\t\treturn this.formatter.getTemplate(this.state) || this.getNonFormattedTemplate() || ''\r\n\t}\r\n}"]},"metadata":{},"sourceType":"module"}