{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { getInitialPhoneDigits, getCountryForPartialE164Number, parsePhoneNumber } from './phoneInputHelpers';\nimport { isCountrySupportedWithError, getSupportedCountries } from './countries';\nexport default function getPhoneInputWithCountryStateUpdateFromNewProps(props, prevProps, state) {\n  var metadata = props.metadata,\n      countries = props.countries,\n      newDefaultCountry = props.defaultCountry,\n      newValue = props.value,\n      newReset = props.reset,\n      international = props.international,\n      displayInitialValueAsLocalNumber = props.displayInitialValueAsLocalNumber,\n      initialValueFormat = props.initialValueFormat;\n  var prevDefaultCountry = prevProps.defaultCountry,\n      prevValue = prevProps.value,\n      prevReset = prevProps.reset;\n  var country = state.country,\n      value = state.value,\n      hasUserSelectedACountry = state.hasUserSelectedACountry;\n\n  var _getInitialPhoneDigits = function _getInitialPhoneDigits(parameters) {\n    return getInitialPhoneDigits(_objectSpread({}, parameters, {\n      international: international,\n      useNationalFormat: displayInitialValueAsLocalNumber || initialValueFormat === 'national',\n      metadata: metadata\n    }));\n  }; // Some users requested a way to reset the component\n  // (both number `<input/>` and country `<select/>`).\n  // Whenever `reset` property changes both number `<input/>`\n  // and country `<select/>` are reset.\n  // It's not implemented as some instance `.reset()` method\n  // because `ref` is forwarded to `<input/>`.\n  // It's also not replaced with just resetting `country` on\n  // external `value` reset, because a user could select a country\n  // and then not input any `value`, and so the selected country\n  // would be \"stuck\", if not using this `reset` property.\n  // https://github.com/catamphetamine/react-phone-number-input/issues/300\n\n\n  if (newReset !== prevReset) {\n    return {\n      phoneDigits: _getInitialPhoneDigits({\n        value: undefined,\n        defaultCountry: newDefaultCountry\n      }),\n      value: undefined,\n      country: newDefaultCountry,\n      hasUserSelectedACountry: undefined\n    };\n  } // `value` is the value currently shown in the component:\n  // it's stored in the component's `state`, and it's not the `value` property.\n  // `prevValue` is \"previous `value` property\".\n  // `newValue` is \"new `value` property\".\n  // If the default country changed\n  // (e.g. in case of ajax GeoIP detection after page loaded)\n  // then select it, but only if the user hasn't already manually\n  // selected a country, and no phone number has been manually entered so far.\n  // Because if the user has already started inputting a phone number\n  // then they're okay with no country being selected at all (\"International\")\n  // and they don't want to be disturbed, don't want their input to be screwed, etc.\n\n\n  if (newDefaultCountry !== prevDefaultCountry) {\n    var isNewDefaultCountrySupported = !newDefaultCountry || isCountrySupportedWithError(newDefaultCountry, metadata);\n\n    var noValueHasBeenEnteredByTheUser = // By default, \"no value has been entered\" means `value` is `undefined`.\n    !value || // When `international` is `true`, and some country has been pre-selected,\n    // then the `<input/>` contains a pre-filled value of `+${countryCallingCode}${leadingDigits}`,\n    // so in case of `international` being `true`, \"the user hasn't entered anything\" situation\n    // doesn't just mean `value` is `undefined`, but could also mean `value` is `+${countryCallingCode}`.\n    international && value === _getInitialPhoneDigits({\n      value: undefined,\n      defaultCountry: prevDefaultCountry\n    }); // Only update the `defaultCountry` property if no phone number\n    // has been entered by the user or pre-set by the application.\n\n\n    var noValueHasBeenEntered = !newValue && noValueHasBeenEnteredByTheUser;\n\n    if (!hasUserSelectedACountry && isNewDefaultCountrySupported && noValueHasBeenEntered) {\n      return {\n        country: newDefaultCountry,\n        // If `phoneDigits` is empty, then automatically select the new `country`\n        // and set `phoneDigits` to `+{getCountryCallingCode(newCountry)}`.\n        // The code assumes that \"no phone number has been entered by the user\",\n        // and no `value` property has been passed, so the `phoneNumber` parameter\n        // of `_getInitialPhoneDigits({ value, phoneNumber, ... })` is `undefined`.\n        phoneDigits: _getInitialPhoneDigits({\n          value: undefined,\n          defaultCountry: newDefaultCountry\n        }),\n        // `value` is `undefined` and it stays so.\n        value: undefined\n      };\n    }\n  } // If a new `value` is set externally.\n  // (e.g. as a result of an ajax API request\n  //  to get user's phone after page loaded)\n  // The first part — `newValue !== prevValue` —\n  // is basically `props.value !== prevProps.value`\n  // so it means \"if value property was changed externally\".\n  // The second part — `newValue !== value` —\n  // is for ignoring the `getDerivedStateFromProps()` call\n  // which happens in `this.onChange()` right after `this.setState()`.\n  // If this `getDerivedStateFromProps()` call isn't ignored\n  // then the country flag would reset on each input.\n\n\n  if (newValue !== prevValue && newValue !== value) {\n    var phoneNumber;\n    var parsedCountry;\n\n    if (newValue) {\n      phoneNumber = parsePhoneNumber(newValue, metadata);\n      var supportedCountries = getSupportedCountries(countries, metadata);\n\n      if (phoneNumber && phoneNumber.country) {\n        // Ignore `else` because all countries are supported in metadata.\n\n        /* istanbul ignore next */\n        if (!supportedCountries || supportedCountries.indexOf(phoneNumber.country) >= 0) {\n          parsedCountry = phoneNumber.country;\n        }\n      } else {\n        parsedCountry = getCountryForPartialE164Number(newValue, {\n          country: undefined,\n          countries: supportedCountries,\n          metadata: metadata\n        });\n      }\n    }\n\n    var hasUserSelectedACountryUpdate;\n\n    if (!newValue) {\n      // Reset `hasUserSelectedACountry` flag in `state`.\n      hasUserSelectedACountryUpdate = {\n        hasUserSelectedACountry: undefined\n      };\n    }\n\n    return _objectSpread({}, hasUserSelectedACountryUpdate, {\n      phoneDigits: _getInitialPhoneDigits({\n        phoneNumber: phoneNumber,\n        value: newValue,\n        defaultCountry: newDefaultCountry\n      }),\n      value: newValue,\n      country: newValue ? parsedCountry : newDefaultCountry\n    });\n  } // `defaultCountry` didn't change.\n  // `value` didn't change.\n  // `phoneDigits` didn't change, because `value` didn't change.\n  //\n  // So no need to update state.\n\n}","map":{"version":3,"sources":["../../source/helpers/getPhoneInputWithCountryStateUpdateFromNewProps.js"],"names":["metadata","countries","newDefaultCountry","newValue","newReset","international","displayInitialValueAsLocalNumber","initialValueFormat","props","prevDefaultCountry","prevValue","prevReset","prevProps","country","value","hasUserSelectedACountry","state","_getInitialPhoneDigits","getInitialPhoneDigits","useNationalFormat","phoneDigits","defaultCountry","undefined","isNewDefaultCountrySupported","isCountrySupportedWithError","noValueHasBeenEnteredByTheUser","noValueHasBeenEntered","phoneNumber","parsePhoneNumber","supportedCountries","getSupportedCountries","parsedCountry","getCountryForPartialE164Number","hasUserSelectedACountryUpdate"],"mappings":"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","sourcesContent":["import {\r\n\tgetInitialPhoneDigits,\r\n\tgetCountryForPartialE164Number,\r\n\tparsePhoneNumber\r\n} from './phoneInputHelpers'\r\n\r\nimport {\r\n\tisCountrySupportedWithError,\r\n\tgetSupportedCountries\r\n} from './countries'\r\n\r\nexport default function getPhoneInputWithCountryStateUpdateFromNewProps(props, prevProps, state) {\r\n\tconst {\r\n\t\tmetadata,\r\n\t\tcountries,\r\n\t\tdefaultCountry: newDefaultCountry,\r\n\t\tvalue: newValue,\r\n\t\treset: newReset,\r\n\t\tinternational,\r\n\t\t// `displayInitialValueAsLocalNumber` property has been\r\n\t\t// superceded by `initialValueFormat` property.\r\n\t\tdisplayInitialValueAsLocalNumber,\r\n\t\tinitialValueFormat\r\n\t} = props\r\n\r\n\tconst {\r\n\t\tdefaultCountry: prevDefaultCountry,\r\n\t\tvalue: prevValue,\r\n\t\treset: prevReset\r\n\t} = prevProps\r\n\r\n\tconst {\r\n\t\tcountry,\r\n\t\tvalue,\r\n\t\t// If the user has already manually selected a country\r\n\t\t// then don't override that already selected country\r\n\t\t// if the `defaultCountry` property changes.\r\n\t\t// That's what `hasUserSelectedACountry` flag is for.\r\n\t\thasUserSelectedACountry\r\n\t} = state\r\n\r\n\tconst _getInitialPhoneDigits = (parameters) => getInitialPhoneDigits({\r\n\t\t...parameters,\r\n\t\tinternational,\r\n\t\tuseNationalFormat: displayInitialValueAsLocalNumber || initialValueFormat === 'national',\r\n\t\tmetadata\r\n\t})\r\n\r\n\t// Some users requested a way to reset the component\r\n\t// (both number `<input/>` and country `<select/>`).\r\n\t// Whenever `reset` property changes both number `<input/>`\r\n\t// and country `<select/>` are reset.\r\n\t// It's not implemented as some instance `.reset()` method\r\n\t// because `ref` is forwarded to `<input/>`.\r\n\t// It's also not replaced with just resetting `country` on\r\n\t// external `value` reset, because a user could select a country\r\n\t// and then not input any `value`, and so the selected country\r\n\t// would be \"stuck\", if not using this `reset` property.\r\n\t// https://github.com/catamphetamine/react-phone-number-input/issues/300\r\n\tif (newReset !== prevReset) {\r\n\t\treturn {\r\n\t\t\tphoneDigits: _getInitialPhoneDigits({\r\n\t\t\t\tvalue: undefined,\r\n\t\t\t\tdefaultCountry: newDefaultCountry\r\n\t\t\t}),\r\n\t\t\tvalue: undefined,\r\n\t\t\tcountry: newDefaultCountry,\r\n\t\t\thasUserSelectedACountry: undefined\r\n\t\t}\r\n\t}\r\n\r\n\t// `value` is the value currently shown in the component:\r\n\t// it's stored in the component's `state`, and it's not the `value` property.\r\n\t// `prevValue` is \"previous `value` property\".\r\n\t// `newValue` is \"new `value` property\".\r\n\r\n\t// If the default country changed\r\n\t// (e.g. in case of ajax GeoIP detection after page loaded)\r\n\t// then select it, but only if the user hasn't already manually\r\n\t// selected a country, and no phone number has been manually entered so far.\r\n\t// Because if the user has already started inputting a phone number\r\n\t// then they're okay with no country being selected at all (\"International\")\r\n\t// and they don't want to be disturbed, don't want their input to be screwed, etc.\r\n\tif (newDefaultCountry !== prevDefaultCountry) {\r\n\t\tconst isNewDefaultCountrySupported = !newDefaultCountry || isCountrySupportedWithError(newDefaultCountry, metadata)\r\n\t\tconst noValueHasBeenEnteredByTheUser = (\r\n\t\t\t// By default, \"no value has been entered\" means `value` is `undefined`.\r\n\t\t\t!value ||\r\n\t\t\t// When `international` is `true`, and some country has been pre-selected,\r\n\t\t\t// then the `<input/>` contains a pre-filled value of `+${countryCallingCode}${leadingDigits}`,\r\n\t\t\t// so in case of `international` being `true`, \"the user hasn't entered anything\" situation\r\n\t\t\t// doesn't just mean `value` is `undefined`, but could also mean `value` is `+${countryCallingCode}`.\r\n\t\t\t(international && value === _getInitialPhoneDigits({\r\n\t\t\t\tvalue: undefined,\r\n\t\t\t\tdefaultCountry: prevDefaultCountry\r\n\t\t\t}))\r\n\t\t)\r\n\t\t// Only update the `defaultCountry` property if no phone number\r\n\t\t// has been entered by the user or pre-set by the application.\r\n\t\tconst noValueHasBeenEntered = !newValue && noValueHasBeenEnteredByTheUser\r\n\t\tif (!hasUserSelectedACountry && isNewDefaultCountrySupported && noValueHasBeenEntered) {\r\n\t\t\treturn {\r\n\t\t\t\tcountry: newDefaultCountry,\r\n\t\t\t\t// If `phoneDigits` is empty, then automatically select the new `country`\r\n\t\t\t\t// and set `phoneDigits` to `+{getCountryCallingCode(newCountry)}`.\r\n\t\t\t\t// The code assumes that \"no phone number has been entered by the user\",\r\n\t\t\t\t// and no `value` property has been passed, so the `phoneNumber` parameter\r\n\t\t\t\t// of `_getInitialPhoneDigits({ value, phoneNumber, ... })` is `undefined`.\r\n\t\t\t\tphoneDigits: _getInitialPhoneDigits({\r\n\t\t\t\t\tvalue: undefined,\r\n\t\t\t\t\tdefaultCountry: newDefaultCountry\r\n\t\t\t\t}),\r\n\t\t\t\t// `value` is `undefined` and it stays so.\r\n\t\t\t\tvalue: undefined\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// If a new `value` is set externally.\r\n\t// (e.g. as a result of an ajax API request\r\n\t//  to get user's phone after page loaded)\r\n\t// The first part — `newValue !== prevValue` —\r\n\t// is basically `props.value !== prevProps.value`\r\n\t// so it means \"if value property was changed externally\".\r\n\t// The second part — `newValue !== value` —\r\n\t// is for ignoring the `getDerivedStateFromProps()` call\r\n\t// which happens in `this.onChange()` right after `this.setState()`.\r\n\t// If this `getDerivedStateFromProps()` call isn't ignored\r\n\t// then the country flag would reset on each input.\r\n\tif (newValue !== prevValue && newValue !== value) {\r\n\t\tlet phoneNumber\r\n\t\tlet parsedCountry\r\n\t\tif (newValue) {\r\n\t\t\tphoneNumber = parsePhoneNumber(newValue, metadata)\r\n\t\t\tconst supportedCountries = getSupportedCountries(countries, metadata)\r\n\t\t\tif (phoneNumber && phoneNumber.country) {\r\n\t\t\t\t// Ignore `else` because all countries are supported in metadata.\r\n\t\t\t\t/* istanbul ignore next */\r\n\t\t\t\tif (!supportedCountries || supportedCountries.indexOf(phoneNumber.country) >= 0) {\r\n\t\t\t\t\tparsedCountry = phoneNumber.country\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tparsedCountry = getCountryForPartialE164Number(newValue, {\r\n\t\t\t\t\tcountry: undefined,\r\n\t\t\t\t\tcountries: supportedCountries,\r\n\t\t\t\t\tmetadata\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\t\tlet hasUserSelectedACountryUpdate\r\n\t\tif (!newValue) {\r\n\t\t\t// Reset `hasUserSelectedACountry` flag in `state`.\r\n\t\t\thasUserSelectedACountryUpdate = {\r\n\t\t\t\thasUserSelectedACountry: undefined\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn {\r\n\t\t\t...hasUserSelectedACountryUpdate,\r\n\t\t\tphoneDigits: _getInitialPhoneDigits({\r\n\t\t\t\tphoneNumber,\r\n\t\t\t\tvalue: newValue,\r\n\t\t\t\tdefaultCountry: newDefaultCountry\r\n\t\t\t}),\r\n\t\t\tvalue: newValue,\r\n\t\t\tcountry: newValue ? parsedCountry : newDefaultCountry\r\n\t\t}\r\n\t}\r\n\r\n\t// `defaultCountry` didn't change.\r\n\t// `value` didn't change.\r\n\t// `phoneDigits` didn't change, because `value` didn't change.\r\n\t//\r\n\t// So no need to update state.\r\n}"]},"metadata":{},"sourceType":"module"}