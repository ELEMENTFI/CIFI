{"ast":null,"code":"import mergeArrays from './mergeArrays';\nexport default function checkNumberLength(nationalNumber, metadata) {\n  return checkNumberLengthForType(nationalNumber, undefined, metadata);\n} // Checks whether a number is possible for the country based on its length.\n// Should only be called for the \"new\" metadata which has \"possible lengths\".\n\nexport function checkNumberLengthForType(nationalNumber, type, metadata) {\n  var type_info = metadata.type(type); // There should always be \"<possiblePengths/>\" set for every type element.\n  // This is declared in the XML schema.\n  // For size efficiency, where a sub-description (e.g. fixed-line)\n  // has the same \"<possiblePengths/>\" as the \"general description\", this is missing,\n  // so we fall back to the \"general description\". Where no numbers of the type\n  // exist at all, there is one possible length (-1) which is guaranteed\n  // not to match the length of any real phone number.\n\n  var possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths(); // let local_lengths    = type_info && type.possibleLengthsLocal() || metadata.possibleLengthsLocal()\n  // Metadata before version `1.0.18` didn't contain `possible_lengths`.\n\n  if (!possible_lengths) {\n    return 'IS_POSSIBLE';\n  }\n\n  if (type === 'FIXED_LINE_OR_MOBILE') {\n    // No such country in metadata.\n\n    /* istanbul ignore next */\n    if (!metadata.type('FIXED_LINE')) {\n      // The rare case has been encountered where no fixedLine data is available\n      // (true for some non-geographic entities), so we just check mobile.\n      return checkNumberLengthForType(nationalNumber, 'MOBILE', metadata);\n    }\n\n    var mobile_type = metadata.type('MOBILE');\n\n    if (mobile_type) {\n      // Merge the mobile data in if there was any. \"Concat\" creates a new\n      // array, it doesn't edit possible_lengths in place, so we don't need a copy.\n      // Note that when adding the possible lengths from mobile, we have\n      // to again check they aren't empty since if they are this indicates\n      // they are the same as the general desc and should be obtained from there.\n      possible_lengths = mergeArrays(possible_lengths, mobile_type.possibleLengths()); // The current list is sorted; we need to merge in the new list and\n      // re-sort (duplicates are okay). Sorting isn't so expensive because\n      // the lists are very small.\n      // if (local_lengths) {\n      // \tlocal_lengths = mergeArrays(local_lengths, mobile_type.possibleLengthsLocal())\n      // } else {\n      // \tlocal_lengths = mobile_type.possibleLengthsLocal()\n      // }\n    }\n  } // If the type doesn't exist then return 'INVALID_LENGTH'.\n  else if (type && !type_info) {\n      return 'INVALID_LENGTH';\n    }\n\n  var actual_length = nationalNumber.length; // In `libphonenumber-js` all \"local-only\" formats are dropped for simplicity.\n  // // This is safe because there is never an overlap beween the possible lengths\n  // // and the local-only lengths; this is checked at build time.\n  // if (local_lengths && local_lengths.indexOf(nationalNumber.length) >= 0)\n  // {\n  // \treturn 'IS_POSSIBLE_LOCAL_ONLY'\n  // }\n\n  var minimum_length = possible_lengths[0];\n\n  if (minimum_length === actual_length) {\n    return 'IS_POSSIBLE';\n  }\n\n  if (minimum_length > actual_length) {\n    return 'TOO_SHORT';\n  }\n\n  if (possible_lengths[possible_lengths.length - 1] < actual_length) {\n    return 'TOO_LONG';\n  } // We skip the first element since we've already checked it.\n\n\n  return possible_lengths.indexOf(actual_length, 1) >= 0 ? 'IS_POSSIBLE' : 'INVALID_LENGTH';\n}","map":{"version":3,"sources":["../../source/helpers/checkNumberLength.js"],"names":["checkNumberLengthForType","type_info","metadata","possible_lengths","type","mobile_type","mergeArrays","actual_length","nationalNumber","minimum_length"],"mappings":"AAAA,OAAA,WAAA,MAAA,eAAA;AAEA,eAAe,SAAA,iBAAA,CAAA,cAAA,EAAA,QAAA,EAAqD;AACnE,SAAOA,wBAAwB,CAAA,cAAA,EAAA,SAAA,EAA/B,QAA+B,CAA/B;EAGD;AACA;;AACA,OAAO,SAAA,wBAAA,CAAA,cAAA,EAAA,IAAA,EAAA,QAAA,EAAkE;AACxE,MAAMC,SAAS,GAAGC,QAAQ,CAARA,IAAAA,CADsD,IACtDA,CAAlB,CADwE,CAGxE;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAIC,gBAAgB,GAAGF,SAAS,IAAIA,SAAS,CAAtBA,eAAaA,EAAbA,IAA4CC,QAAQ,CAVH,eAULA,EAAnE,CAVwE,CAWxE;AAEA;;AACA,MAAI,CAAJ,gBAAA,EAAuB;AACtB,WAAA,aAAA;AACA;;AAED,MAAIE,IAAI,KAAR,sBAAA,EAAqC;AACpC;;AACA;AACA,QAAI,CAACF,QAAQ,CAARA,IAAAA,CAAL,YAAKA,CAAL,EAAkC;AACjC;AACA;AACA,aAAOF,wBAAwB,CAAA,cAAA,EAAA,QAAA,EAA/B,QAA+B,CAA/B;AACA;;AAED,QAAMK,WAAW,GAAGH,QAAQ,CAARA,IAAAA,CAApB,QAAoBA,CAApB;;AACA,QAAA,WAAA,EAAiB;AAChB;AACA;AACA;AACA;AACA;AACAC,MAAAA,gBAAgB,GAAGG,WAAW,CAAA,gBAAA,EAAmBD,WAAW,CAN5C,eAMiCA,EAAnB,CAA9BF,CANgB,CAOhB;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA1BF,GAAA,CA4BA;AA5BA,OA6BK,IAAIC,IAAI,IAAI,CAAZ,SAAA,EAAwB;AAC5B,aAAA,gBAAA;AACA;;AAED,MAAMG,aAAa,GAAGC,cAAc,CAnDoC,MAmDxE,CAnDwE,CAqDxE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,cAAc,GAAGN,gBAAgB,CAAvC,CAAuC,CAAvC;;AAEA,MAAIM,cAAc,KAAlB,aAAA,EAAsC;AACrC,WAAA,aAAA;AACA;;AAED,MAAIA,cAAc,GAAlB,aAAA,EAAoC;AACnC,WAAA,WAAA;AACA;;AAED,MAAIN,gBAAgB,CAACA,gBAAgB,CAAhBA,MAAAA,GAAjBA,CAAgB,CAAhBA,GAAJ,aAAA,EAAmE;AAClE,WAAA,UAAA;AAxEuE,GAAA,CA2ExE;;;AACA,SAAOA,gBAAgB,CAAhBA,OAAAA,CAAAA,aAAAA,EAAAA,CAAAA,KAAAA,CAAAA,GAAAA,aAAAA,GAAP,gBAAA;AACA","sourcesContent":["import mergeArrays from './mergeArrays'\r\n\r\nexport default function checkNumberLength(nationalNumber, metadata) {\r\n\treturn checkNumberLengthForType(nationalNumber, undefined, metadata)\r\n}\r\n\r\n// Checks whether a number is possible for the country based on its length.\r\n// Should only be called for the \"new\" metadata which has \"possible lengths\".\r\nexport function checkNumberLengthForType(nationalNumber, type, metadata) {\r\n\tconst type_info = metadata.type(type)\r\n\r\n\t// There should always be \"<possiblePengths/>\" set for every type element.\r\n\t// This is declared in the XML schema.\r\n\t// For size efficiency, where a sub-description (e.g. fixed-line)\r\n\t// has the same \"<possiblePengths/>\" as the \"general description\", this is missing,\r\n\t// so we fall back to the \"general description\". Where no numbers of the type\r\n\t// exist at all, there is one possible length (-1) which is guaranteed\r\n\t// not to match the length of any real phone number.\r\n\tlet possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths()\r\n\t// let local_lengths    = type_info && type.possibleLengthsLocal() || metadata.possibleLengthsLocal()\r\n\r\n\t// Metadata before version `1.0.18` didn't contain `possible_lengths`.\r\n\tif (!possible_lengths) {\r\n\t\treturn 'IS_POSSIBLE'\r\n\t}\r\n\r\n\tif (type === 'FIXED_LINE_OR_MOBILE') {\r\n\t\t// No such country in metadata.\r\n\t\t/* istanbul ignore next */\r\n\t\tif (!metadata.type('FIXED_LINE')) {\r\n\t\t\t// The rare case has been encountered where no fixedLine data is available\r\n\t\t\t// (true for some non-geographic entities), so we just check mobile.\r\n\t\t\treturn checkNumberLengthForType(nationalNumber, 'MOBILE', metadata)\r\n\t\t}\r\n\r\n\t\tconst mobile_type = metadata.type('MOBILE')\r\n\t\tif (mobile_type) {\r\n\t\t\t// Merge the mobile data in if there was any. \"Concat\" creates a new\r\n\t\t\t// array, it doesn't edit possible_lengths in place, so we don't need a copy.\r\n\t\t\t// Note that when adding the possible lengths from mobile, we have\r\n\t\t\t// to again check they aren't empty since if they are this indicates\r\n\t\t\t// they are the same as the general desc and should be obtained from there.\r\n\t\t\tpossible_lengths = mergeArrays(possible_lengths, mobile_type.possibleLengths())\r\n\t\t\t// The current list is sorted; we need to merge in the new list and\r\n\t\t\t// re-sort (duplicates are okay). Sorting isn't so expensive because\r\n\t\t\t// the lists are very small.\r\n\r\n\t\t\t// if (local_lengths) {\r\n\t\t\t// \tlocal_lengths = mergeArrays(local_lengths, mobile_type.possibleLengthsLocal())\r\n\t\t\t// } else {\r\n\t\t\t// \tlocal_lengths = mobile_type.possibleLengthsLocal()\r\n\t\t\t// }\r\n\t\t}\r\n\t}\r\n\t// If the type doesn't exist then return 'INVALID_LENGTH'.\r\n\telse if (type && !type_info) {\r\n\t\treturn 'INVALID_LENGTH'\r\n\t}\r\n\r\n\tconst actual_length = nationalNumber.length\r\n\r\n\t// In `libphonenumber-js` all \"local-only\" formats are dropped for simplicity.\r\n\t// // This is safe because there is never an overlap beween the possible lengths\r\n\t// // and the local-only lengths; this is checked at build time.\r\n\t// if (local_lengths && local_lengths.indexOf(nationalNumber.length) >= 0)\r\n\t// {\r\n\t// \treturn 'IS_POSSIBLE_LOCAL_ONLY'\r\n\t// }\r\n\r\n\tconst minimum_length = possible_lengths[0]\r\n\r\n\tif (minimum_length === actual_length) {\r\n\t\treturn 'IS_POSSIBLE'\r\n\t}\r\n\r\n\tif (minimum_length > actual_length) {\r\n\t\treturn 'TOO_SHORT'\r\n\t}\r\n\r\n\tif (possible_lengths[possible_lengths.length - 1] < actual_length) {\r\n\t\treturn 'TOO_LONG'\r\n\t}\r\n\r\n\t// We skip the first element since we've already checked it.\r\n\treturn possible_lengths.indexOf(actual_length, 1) >= 0 ? 'IS_POSSIBLE' : 'INVALID_LENGTH'\r\n}"]},"metadata":{},"sourceType":"module"}