{"ast":null,"code":"'use strict';\n\nconst webcrypto = require('../webcrypto.js')();\n\nconst nodeify = require('../nodeify');\n\nconst BN = require('asn1.js').bignum;\n\nconst util = require('../util');\n\nconst toBase64 = util.toBase64;\nconst toBn = util.toBn;\nconst bits = {\n  'P-256': 256,\n  'P-384': 384,\n  'P-521': 521\n};\n\nexports.generateEphmeralKeyPair = function (curve, callback) {\n  nodeify(webcrypto.subtle.generateKey({\n    name: 'ECDH',\n    namedCurve: curve\n  }, true, ['deriveBits']).then(pair => {\n    // forcePrivate is used for testing only\n    const genSharedKey = (theirPub, forcePrivate, cb) => {\n      if (typeof forcePrivate === 'function') {\n        cb = forcePrivate;\n        forcePrivate = undefined;\n      }\n\n      let privateKey;\n\n      if (forcePrivate) {\n        privateKey = webcrypto.subtle.importKey('jwk', unmarshalPrivateKey(curve, forcePrivate), {\n          name: 'ECDH',\n          namedCurve: curve\n        }, false, ['deriveBits']);\n      } else {\n        privateKey = Promise.resolve(pair.privateKey);\n      }\n\n      const keys = Promise.all([webcrypto.subtle.importKey('jwk', unmarshalPublicKey(curve, theirPub), {\n        name: 'ECDH',\n        namedCurve: curve\n      }, false, []), privateKey]);\n      nodeify(keys.then(keys => webcrypto.subtle.deriveBits({\n        name: 'ECDH',\n        namedCurve: curve,\n        public: keys[0]\n      }, keys[1], bits[curve])).then(bits => Buffer.from(bits)), cb);\n    };\n\n    return webcrypto.subtle.exportKey('jwk', pair.publicKey).then(publicKey => {\n      return {\n        key: marshalPublicKey(publicKey),\n        genSharedKey\n      };\n    });\n  }), callback);\n};\n\nconst curveLengths = {\n  'P-256': 32,\n  'P-384': 48,\n  'P-521': 66\n}; // Marshal converts a jwk encodec ECDH public key into the\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\n// go-ipfs uses)\n\nfunction marshalPublicKey(jwk) {\n  const byteLen = curveLengths[jwk.crv];\n  return Buffer.concat([Buffer.from([4]), // uncompressed point\n  toBn(jwk.x).toArrayLike(Buffer, 'be', byteLen), toBn(jwk.y).toArrayLike(Buffer, 'be', byteLen)], 1 + byteLen * 2);\n} // Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\n\n\nfunction unmarshalPublicKey(curve, key) {\n  const byteLen = curveLengths[curve];\n\n  if (!key.slice(0, 1).equals(Buffer.from([4]))) {\n    throw new Error('Invalid key format');\n  }\n\n  const x = new BN(key.slice(1, byteLen + 1));\n  const y = new BN(key.slice(1 + byteLen));\n  return {\n    kty: 'EC',\n    crv: curve,\n    x: toBase64(x, byteLen),\n    y: toBase64(y, byteLen),\n    ext: true\n  };\n}\n\nfunction unmarshalPrivateKey(curve, key) {\n  const result = unmarshalPublicKey(curve, key.public);\n  result.d = toBase64(new BN(key.private));\n  return result;\n}","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/algosigner-react/CIFI/WebApp/NFTWebAPP/node_modules/libp2p-crypto/src/keys/ecdh-browser.js"],"names":["webcrypto","require","nodeify","BN","bignum","util","toBase64","toBn","bits","exports","generateEphmeralKeyPair","curve","callback","subtle","generateKey","name","namedCurve","then","pair","genSharedKey","theirPub","forcePrivate","cb","undefined","privateKey","importKey","unmarshalPrivateKey","Promise","resolve","keys","all","unmarshalPublicKey","deriveBits","public","Buffer","from","exportKey","publicKey","key","marshalPublicKey","curveLengths","jwk","byteLen","crv","concat","x","toArrayLike","y","slice","equals","Error","kty","ext","result","d","private"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nconst webcrypto = require('../webcrypto.js')()\r\nconst nodeify = require('../nodeify')\r\nconst BN = require('asn1.js').bignum\r\n\r\nconst util = require('../util')\r\nconst toBase64 = util.toBase64\r\nconst toBn = util.toBn\r\n\r\nconst bits = {\r\n  'P-256': 256,\r\n  'P-384': 384,\r\n  'P-521': 521\r\n}\r\n\r\nexports.generateEphmeralKeyPair = function (curve, callback) {\r\n  nodeify(webcrypto.subtle.generateKey(\r\n    {\r\n      name: 'ECDH',\r\n      namedCurve: curve\r\n    },\r\n    true,\r\n    ['deriveBits']\r\n  ).then((pair) => {\r\n    // forcePrivate is used for testing only\r\n    const genSharedKey = (theirPub, forcePrivate, cb) => {\r\n      if (typeof forcePrivate === 'function') {\r\n        cb = forcePrivate\r\n        forcePrivate = undefined\r\n      }\r\n\r\n      let privateKey\r\n\r\n      if (forcePrivate) {\r\n        privateKey = webcrypto.subtle.importKey(\r\n          'jwk',\r\n          unmarshalPrivateKey(curve, forcePrivate),\r\n          {\r\n            name: 'ECDH',\r\n            namedCurve: curve\r\n          },\r\n          false,\r\n          ['deriveBits']\r\n        )\r\n      } else {\r\n        privateKey = Promise.resolve(pair.privateKey)\r\n      }\r\n\r\n      const keys = Promise.all([\r\n        webcrypto.subtle.importKey(\r\n          'jwk',\r\n          unmarshalPublicKey(curve, theirPub),\r\n          {\r\n            name: 'ECDH',\r\n            namedCurve: curve\r\n          },\r\n          false,\r\n          []\r\n        ),\r\n        privateKey\r\n      ])\r\n\r\n      nodeify(keys.then((keys) => webcrypto.subtle.deriveBits(\r\n        {\r\n          name: 'ECDH',\r\n          namedCurve: curve,\r\n          public: keys[0]\r\n        },\r\n        keys[1],\r\n        bits[curve]\r\n      )).then((bits) => Buffer.from(bits)), cb)\r\n    }\r\n\r\n    return webcrypto.subtle.exportKey('jwk', pair.publicKey)\r\n      .then((publicKey) => {\r\n        return {\r\n          key: marshalPublicKey(publicKey),\r\n          genSharedKey\r\n        }\r\n      })\r\n  }), callback)\r\n}\r\n\r\nconst curveLengths = {\r\n  'P-256': 32,\r\n  'P-384': 48,\r\n  'P-521': 66\r\n}\r\n\r\n// Marshal converts a jwk encodec ECDH public key into the\r\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\r\n// go-ipfs uses)\r\nfunction marshalPublicKey (jwk) {\r\n  const byteLen = curveLengths[jwk.crv]\r\n\r\n  return Buffer.concat([\r\n    Buffer.from([4]), // uncompressed point\r\n    toBn(jwk.x).toArrayLike(Buffer, 'be', byteLen),\r\n    toBn(jwk.y).toArrayLike(Buffer, 'be', byteLen)\r\n  ], 1 + byteLen * 2)\r\n}\r\n\r\n// Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\r\nfunction unmarshalPublicKey (curve, key) {\r\n  const byteLen = curveLengths[curve]\r\n\r\n  if (!key.slice(0, 1).equals(Buffer.from([4]))) {\r\n    throw new Error('Invalid key format')\r\n  }\r\n  const x = new BN(key.slice(1, byteLen + 1))\r\n  const y = new BN(key.slice(1 + byteLen))\r\n\r\n  return {\r\n    kty: 'EC',\r\n    crv: curve,\r\n    x: toBase64(x, byteLen),\r\n    y: toBase64(y, byteLen),\r\n    ext: true\r\n  }\r\n}\r\n\r\nfunction unmarshalPrivateKey (curve, key) {\r\n  const result = unmarshalPublicKey(curve, key.public)\r\n  result.d = toBase64(new BN(key.private))\r\n  return result\r\n}\r\n"]},"metadata":{},"sourceType":"script"}