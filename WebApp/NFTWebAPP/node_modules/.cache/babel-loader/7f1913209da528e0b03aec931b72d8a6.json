{"ast":null,"code":"// This is a port of Google Android `libphonenumber`'s\n// `phonenumberutil.js` of December 31th, 2018.\n//\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\nimport { VALID_DIGITS, PLUS_CHARS, MIN_LENGTH_FOR_NSN, MAX_LENGTH_FOR_NSN } from './constants';\nimport ParseError from './ParseError';\nimport Metadata from './metadata';\nimport isViablePhoneNumber from './helpers/isViablePhoneNumber';\nimport extractExtension from './helpers/extension/extractExtension';\nimport parseIncompletePhoneNumber from './parseIncompletePhoneNumber';\nimport getCountryCallingCode from './getCountryCallingCode';\nimport { isPossibleNumber } from './isPossibleNumber_';\nimport { parseRFC3966 } from './helpers/RFC3966';\nimport PhoneNumber from './PhoneNumber';\nimport matchesEntirely from './helpers/matchesEntirely';\nimport extractCountryCallingCode from './helpers/extractCountryCallingCode';\nimport extractCountryCallingCodeFromInternationalNumberWithoutPlusSign from './helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign';\nimport extractNationalNumber from './helpers/extractNationalNumber';\nimport stripIddPrefix from './helpers/stripIddPrefix';\nimport getCountryByCallingCode from './helpers/getCountryByCallingCode'; // We don't allow input strings for parsing to be longer than 250 chars.\n// This prevents malicious input from consuming CPU.\n\nvar MAX_INPUT_STRING_LENGTH = 250; // This consists of the plus symbol, digits, and arabic-indic digits.\n\nvar PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']'); // Regular expression of trailing characters that we want to remove.\n// A trailing `#` is sometimes used when writing phone numbers with extensions in US.\n// Example: \"+1 (645) 123 1234-910#\" number has extension \"910\".\n\nvar AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + '#' + ']+$');\nvar USE_NON_GEOGRAPHIC_COUNTRY_CODE = false; // Examples:\n//\n// ```js\n// parse('8 (800) 555-35-35', 'RU')\n// parse('8 (800) 555-35-35', 'RU', metadata)\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\n// parse('+7 800 555 35 35')\n// parse('+7 800 555 35 35', metadata)\n// ```\n//\n\nexport default function parse(text, options, metadata) {\n  // If assigning the `{}` default value is moved to the arguments above,\n  // code coverage would decrease for some weird reason.\n  options = options || {};\n  metadata = new Metadata(metadata); // Validate `defaultCountry`.\n\n  if (options.defaultCountry && !metadata.hasCountry(options.defaultCountry)) {\n    if (options.v2) {\n      throw new ParseError('INVALID_COUNTRY');\n    }\n\n    throw new Error(\"Unknown country: \".concat(options.defaultCountry));\n  } // Parse the phone number.\n\n\n  var _parseInput = parseInput(text, options.v2, options.extract),\n      formattedPhoneNumber = _parseInput.number,\n      ext = _parseInput.ext; // If the phone number is not viable then return nothing.\n\n\n  if (!formattedPhoneNumber) {\n    if (options.v2) {\n      throw new ParseError('NOT_A_NUMBER');\n    }\n\n    return {};\n  }\n\n  var _parsePhoneNumber = parsePhoneNumber(formattedPhoneNumber, options.defaultCountry, options.defaultCallingCode, metadata),\n      country = _parsePhoneNumber.country,\n      nationalNumber = _parsePhoneNumber.nationalNumber,\n      countryCallingCode = _parsePhoneNumber.countryCallingCode,\n      carrierCode = _parsePhoneNumber.carrierCode;\n\n  if (!metadata.hasSelectedNumberingPlan()) {\n    if (options.v2) {\n      throw new ParseError('INVALID_COUNTRY');\n    }\n\n    return {};\n  } // Validate national (significant) number length.\n\n\n  if (!nationalNumber || nationalNumber.length < MIN_LENGTH_FOR_NSN) {\n    // Won't throw here because the regexp already demands length > 1.\n\n    /* istanbul ignore if */\n    if (options.v2) {\n      throw new ParseError('TOO_SHORT');\n    } // Google's demo just throws an error in this case.\n\n\n    return {};\n  } // Validate national (significant) number length.\n  //\n  // A sidenote:\n  //\n  // They say that sometimes national (significant) numbers\n  // can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\n  // https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\n  // Such numbers will just be discarded.\n  //\n\n\n  if (nationalNumber.length > MAX_LENGTH_FOR_NSN) {\n    if (options.v2) {\n      throw new ParseError('TOO_LONG');\n    } // Google's demo just throws an error in this case.\n\n\n    return {};\n  }\n\n  if (options.v2) {\n    var phoneNumber = new PhoneNumber(countryCallingCode, nationalNumber, metadata.metadata);\n\n    if (country) {\n      phoneNumber.country = country;\n    }\n\n    if (carrierCode) {\n      phoneNumber.carrierCode = carrierCode;\n    }\n\n    if (ext) {\n      phoneNumber.ext = ext;\n    }\n\n    return phoneNumber;\n  } // Check if national phone number pattern matches the number.\n  // National number pattern is different for each country,\n  // even for those ones which are part of the \"NANPA\" group.\n\n\n  var valid = (options.extended ? metadata.hasSelectedNumberingPlan() : country) ? matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) : false;\n\n  if (!options.extended) {\n    return valid ? result(country, nationalNumber, ext) : {};\n  } // isInternational: countryCallingCode !== undefined\n\n\n  return {\n    country: country,\n    countryCallingCode: countryCallingCode,\n    carrierCode: carrierCode,\n    valid: valid,\n    possible: valid ? true : options.extended === true && metadata.possibleLengths() && isPossibleNumber(nationalNumber, metadata) ? true : false,\n    phone: nationalNumber,\n    ext: ext\n  };\n}\n/**\r\n * Extracts a formatted phone number from text.\r\n * Doesn't guarantee that the extracted phone number\r\n * is a valid phone number (for example, doesn't validate its length).\r\n * @param  {string} text\r\n * @param  {boolean} [extract] — If `false`, then will parse the entire `text` as a phone number.\r\n * @param  {boolean} [throwOnError] — By default, it won't throw if the text is too long.\r\n * @return {string}\r\n * @example\r\n * // Returns \"(213) 373-4253\".\r\n * extractFormattedPhoneNumber(\"Call (213) 373-4253 for assistance.\")\r\n */\n\nfunction extractFormattedPhoneNumber(text, extract, throwOnError) {\n  if (!text) {\n    return;\n  }\n\n  if (text.length > MAX_INPUT_STRING_LENGTH) {\n    if (throwOnError) {\n      throw new ParseError('TOO_LONG');\n    }\n\n    return;\n  }\n\n  if (extract === false) {\n    return text;\n  } // Attempt to extract a possible number from the string passed in\n\n\n  var startsAt = text.search(PHONE_NUMBER_START_PATTERN);\n\n  if (startsAt < 0) {\n    return;\n  }\n\n  return text // Trim everything to the left of the phone number\n  .slice(startsAt) // Remove trailing non-numerical characters\n  .replace(AFTER_PHONE_NUMBER_END_PATTERN, '');\n}\n/**\r\n * @param  {string} text - Input.\r\n * @param  {boolean} v2 - Legacy API functions don't pass `v2: true` flag.\r\n * @param  {boolean} [extract] - Whether to extract a phone number from `text`, or attempt to parse the entire text as a phone number.\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\n\n\nfunction parseInput(text, v2, extract) {\n  // Parse RFC 3966 phone number URI.\n  if (text && text.indexOf('tel:') === 0) {\n    return parseRFC3966(text);\n  }\n\n  var number = extractFormattedPhoneNumber(text, extract, v2); // If the phone number is not viable, then abort.\n\n  if (!number || !isViablePhoneNumber(number)) {\n    return {};\n  } // Attempt to parse extension first, since it doesn't require region-specific\n  // data and we want to have the non-normalised number here.\n\n\n  var withExtensionStripped = extractExtension(number);\n\n  if (withExtensionStripped.ext) {\n    return withExtensionStripped;\n  }\n\n  return {\n    number: number\n  };\n}\n/**\r\n * Creates `parse()` result object.\r\n */\n\n\nfunction result(country, nationalNumber, ext) {\n  var result = {\n    country: country,\n    phone: nationalNumber\n  };\n\n  if (ext) {\n    result.ext = ext;\n  }\n\n  return result;\n}\n/**\r\n * Parses a viable phone number.\r\n * @param {string} formattedPhoneNumber — Example: \"(213) 373-4253\".\r\n * @param {string} [defaultCountry]\r\n * @param {string} [defaultCallingCode]\r\n * @param {Metadata} metadata\r\n * @return {object} Returns `{ country: string?, countryCallingCode: string?, nationalNumber: string? }`.\r\n */\n\n\nfunction parsePhoneNumber(formattedPhoneNumber, defaultCountry, defaultCallingCode, metadata) {\n  // Extract calling code from phone number.\n  var _extractCountryCallin = extractCountryCallingCode(parseIncompletePhoneNumber(formattedPhoneNumber), defaultCountry, defaultCallingCode, metadata.metadata),\n      countryCallingCode = _extractCountryCallin.countryCallingCode,\n      number = _extractCountryCallin.number; // Choose a country by `countryCallingCode`.\n\n\n  var country;\n\n  if (countryCallingCode) {\n    metadata.selectNumberingPlan(countryCallingCode);\n  } // If `formattedPhoneNumber` is in \"national\" format\n  // then `number` is defined and `countryCallingCode` isn't.\n  else if (number && (defaultCountry || defaultCallingCode)) {\n      metadata.selectNumberingPlan(defaultCountry, defaultCallingCode);\n\n      if (defaultCountry) {\n        country = defaultCountry;\n      } else {\n        /* istanbul ignore if */\n        if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\n          if (metadata.isNonGeographicCallingCode(defaultCallingCode)) {\n            country = '001';\n          }\n        }\n      }\n\n      countryCallingCode = defaultCallingCode || getCountryCallingCode(defaultCountry, metadata.metadata);\n    } else return {};\n\n  if (!number) {\n    return {\n      countryCallingCode: countryCallingCode\n    };\n  }\n\n  var _extractNationalNumbe = extractNationalNumber(parseIncompletePhoneNumber(number), metadata),\n      nationalNumber = _extractNationalNumbe.nationalNumber,\n      carrierCode = _extractNationalNumbe.carrierCode; // Sometimes there are several countries\n  // corresponding to the same country phone code\n  // (e.g. NANPA countries all having `1` country phone code).\n  // Therefore, to reliably determine the exact country,\n  // national (significant) number should have been parsed first.\n  //\n  // When `metadata.json` is generated, all \"ambiguous\" country phone codes\n  // get their countries populated with the full set of\n  // \"phone number type\" regular expressions.\n  //\n\n\n  var exactCountry = getCountryByCallingCode(countryCallingCode, nationalNumber, metadata);\n\n  if (exactCountry) {\n    country = exactCountry;\n    /* istanbul ignore if */\n\n    if (exactCountry === '001') {// Can't happen with `USE_NON_GEOGRAPHIC_COUNTRY_CODE` being `false`.\n      // If `USE_NON_GEOGRAPHIC_COUNTRY_CODE` is set to `true` for some reason,\n      // then remove the \"istanbul ignore if\".\n    } else {\n      metadata.country(country);\n    }\n  }\n\n  return {\n    country: country,\n    countryCallingCode: countryCallingCode,\n    nationalNumber: nationalNumber,\n    carrierCode: carrierCode\n  };\n}","map":{"version":3,"sources":["../source/parse_.js"],"names":["MAX_INPUT_STRING_LENGTH","PHONE_NUMBER_START_PATTERN","AFTER_PHONE_NUMBER_END_PATTERN","USE_NON_GEOGRAPHIC_COUNTRY_CODE","options","metadata","formattedPhoneNumber","ext","parseInput","country","nationalNumber","countryCallingCode","carrierCode","parsePhoneNumber","phoneNumber","valid","matchesEntirely","result","possible","isPossibleNumber","phone","text","extract","startsAt","parseRFC3966","number","extractFormattedPhoneNumber","isViablePhoneNumber","withExtensionStripped","extractExtension","extractCountryCallingCode","parseIncompletePhoneNumber","defaultCountry","defaultCallingCode","getCountryCallingCode","extractNationalNumber","exactCountry","getCountryByCallingCode"],"mappings":"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","sourcesContent":["// This is a port of Google Android `libphonenumber`'s\r\n// `phonenumberutil.js` of December 31th, 2018.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\r\n\r\nimport {\r\n\tVALID_DIGITS,\r\n\tPLUS_CHARS,\r\n\tMIN_LENGTH_FOR_NSN,\r\n\tMAX_LENGTH_FOR_NSN\r\n} from './constants'\r\n\r\nimport ParseError from './ParseError'\r\nimport Metadata from './metadata'\r\nimport isViablePhoneNumber from './helpers/isViablePhoneNumber'\r\nimport extractExtension from './helpers/extension/extractExtension'\r\nimport parseIncompletePhoneNumber from './parseIncompletePhoneNumber'\r\nimport getCountryCallingCode from './getCountryCallingCode'\r\nimport { isPossibleNumber } from './isPossibleNumber_'\r\nimport { parseRFC3966 } from './helpers/RFC3966'\r\nimport PhoneNumber from './PhoneNumber'\r\nimport matchesEntirely from './helpers/matchesEntirely'\r\nimport extractCountryCallingCode from './helpers/extractCountryCallingCode'\r\nimport extractCountryCallingCodeFromInternationalNumberWithoutPlusSign from './helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign'\r\nimport extractNationalNumber from './helpers/extractNationalNumber'\r\nimport stripIddPrefix from './helpers/stripIddPrefix'\r\nimport getCountryByCallingCode from './helpers/getCountryByCallingCode'\r\n\r\n// We don't allow input strings for parsing to be longer than 250 chars.\r\n// This prevents malicious input from consuming CPU.\r\nconst MAX_INPUT_STRING_LENGTH = 250\r\n\r\n// This consists of the plus symbol, digits, and arabic-indic digits.\r\nconst PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']')\r\n\r\n// Regular expression of trailing characters that we want to remove.\r\n// A trailing `#` is sometimes used when writing phone numbers with extensions in US.\r\n// Example: \"+1 (645) 123 1234-910#\" number has extension \"910\".\r\nconst AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + '#' + ']+$')\r\n\r\nconst USE_NON_GEOGRAPHIC_COUNTRY_CODE = false\r\n\r\n// Examples:\r\n//\r\n// ```js\r\n// parse('8 (800) 555-35-35', 'RU')\r\n// parse('8 (800) 555-35-35', 'RU', metadata)\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\r\n// parse('+7 800 555 35 35')\r\n// parse('+7 800 555 35 35', metadata)\r\n// ```\r\n//\r\nexport default function parse(text, options, metadata) {\r\n\t// If assigning the `{}` default value is moved to the arguments above,\r\n\t// code coverage would decrease for some weird reason.\r\n\toptions = options || {}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\t// Validate `defaultCountry`.\r\n\tif (options.defaultCountry && !metadata.hasCountry(options.defaultCountry)) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('INVALID_COUNTRY')\r\n\t\t}\r\n\t\tthrow new Error(`Unknown country: ${options.defaultCountry}`)\r\n\t}\r\n\r\n\t// Parse the phone number.\r\n\tconst { number: formattedPhoneNumber, ext } = parseInput(text, options.v2, options.extract)\r\n\r\n\t// If the phone number is not viable then return nothing.\r\n\tif (!formattedPhoneNumber) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('NOT_A_NUMBER')\r\n\t\t}\r\n\t\treturn {}\r\n\t}\r\n\r\n\tconst {\r\n\t\tcountry,\r\n\t\tnationalNumber,\r\n\t\tcountryCallingCode,\r\n\t\tcarrierCode\r\n\t} = parsePhoneNumber(\r\n\t\tformattedPhoneNumber,\r\n\t\toptions.defaultCountry,\r\n\t\toptions.defaultCallingCode,\r\n\t\tmetadata\r\n\t)\r\n\r\n\tif (!metadata.hasSelectedNumberingPlan()) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('INVALID_COUNTRY')\r\n\t\t}\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\tif (!nationalNumber || nationalNumber.length < MIN_LENGTH_FOR_NSN) {\r\n\t\t// Won't throw here because the regexp already demands length > 1.\r\n\t\t/* istanbul ignore if */\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('TOO_SHORT')\r\n\t\t}\r\n\t\t// Google's demo just throws an error in this case.\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\t//\r\n\t// A sidenote:\r\n\t//\r\n\t// They say that sometimes national (significant) numbers\r\n\t// can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\r\n\t// https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\r\n\t// Such numbers will just be discarded.\r\n\t//\r\n\tif (nationalNumber.length > MAX_LENGTH_FOR_NSN) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('TOO_LONG')\r\n\t\t}\r\n\t\t// Google's demo just throws an error in this case.\r\n\t\treturn {}\r\n\t}\r\n\r\n\tif (options.v2) {\r\n\t\tconst phoneNumber = new PhoneNumber(\r\n\t\t\tcountryCallingCode,\r\n\t\t\tnationalNumber,\r\n\t\t\tmetadata.metadata\r\n\t\t)\r\n\t\tif (country) {\r\n\t\t\tphoneNumber.country = country\r\n\t\t}\r\n\t\tif (carrierCode) {\r\n\t\t\tphoneNumber.carrierCode = carrierCode\r\n\t\t}\r\n\t\tif (ext) {\r\n\t\t\tphoneNumber.ext = ext\r\n\t\t}\r\n\t\treturn phoneNumber\r\n\t}\r\n\r\n\t// Check if national phone number pattern matches the number.\r\n\t// National number pattern is different for each country,\r\n\t// even for those ones which are part of the \"NANPA\" group.\r\n\tconst valid = (options.extended ? metadata.hasSelectedNumberingPlan() : country) ?\r\n\t\tmatchesEntirely(nationalNumber, metadata.nationalNumberPattern()) :\r\n\t\tfalse\r\n\r\n\tif (!options.extended) {\r\n\t\treturn valid ? result(country, nationalNumber, ext) : {}\r\n\t}\r\n\r\n\t// isInternational: countryCallingCode !== undefined\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode,\r\n\t\tcarrierCode,\r\n\t\tvalid,\r\n\t\tpossible: valid ? true : (\r\n\t\t\toptions.extended === true &&\r\n\t\t\tmetadata.possibleLengths() &&\r\n\t\t\tisPossibleNumber(nationalNumber, metadata) ? true : false\r\n\t\t),\r\n\t\tphone: nationalNumber,\r\n\t\text\r\n\t}\r\n}\r\n\r\n/**\r\n * Extracts a formatted phone number from text.\r\n * Doesn't guarantee that the extracted phone number\r\n * is a valid phone number (for example, doesn't validate its length).\r\n * @param  {string} text\r\n * @param  {boolean} [extract] — If `false`, then will parse the entire `text` as a phone number.\r\n * @param  {boolean} [throwOnError] — By default, it won't throw if the text is too long.\r\n * @return {string}\r\n * @example\r\n * // Returns \"(213) 373-4253\".\r\n * extractFormattedPhoneNumber(\"Call (213) 373-4253 for assistance.\")\r\n */\r\nfunction extractFormattedPhoneNumber(text, extract, throwOnError) {\r\n\tif (!text) {\r\n\t\treturn\r\n\t}\r\n\tif (text.length > MAX_INPUT_STRING_LENGTH) {\r\n\t\tif (throwOnError) {\r\n\t\t\tthrow new ParseError('TOO_LONG')\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\tif (extract === false) {\r\n\t\treturn text\r\n\t}\r\n\t// Attempt to extract a possible number from the string passed in\r\n\tconst startsAt = text.search(PHONE_NUMBER_START_PATTERN)\r\n\tif (startsAt < 0) {\r\n\t\treturn\r\n\t}\r\n\treturn text\r\n\t\t// Trim everything to the left of the phone number\r\n\t\t.slice(startsAt)\r\n\t\t// Remove trailing non-numerical characters\r\n\t\t.replace(AFTER_PHONE_NUMBER_END_PATTERN, '')\r\n}\r\n\r\n/**\r\n * @param  {string} text - Input.\r\n * @param  {boolean} v2 - Legacy API functions don't pass `v2: true` flag.\r\n * @param  {boolean} [extract] - Whether to extract a phone number from `text`, or attempt to parse the entire text as a phone number.\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\r\nfunction parseInput(text, v2, extract) {\r\n\t// Parse RFC 3966 phone number URI.\r\n\tif (text && text.indexOf('tel:') === 0) {\r\n\t\treturn parseRFC3966(text)\r\n\t}\r\n\tlet number = extractFormattedPhoneNumber(text, extract, v2)\r\n\t// If the phone number is not viable, then abort.\r\n\tif (!number || !isViablePhoneNumber(number)) {\r\n\t\treturn {}\r\n\t}\r\n\t// Attempt to parse extension first, since it doesn't require region-specific\r\n\t// data and we want to have the non-normalised number here.\r\n\tconst withExtensionStripped = extractExtension(number)\r\n\tif (withExtensionStripped.ext) {\r\n\t\treturn withExtensionStripped\r\n\t}\r\n\treturn { number }\r\n}\r\n\r\n/**\r\n * Creates `parse()` result object.\r\n */\r\nfunction result(country, nationalNumber, ext) {\r\n\tconst result = {\r\n\t\tcountry,\r\n\t\tphone: nationalNumber\r\n\t}\r\n\tif (ext) {\r\n\t\tresult.ext = ext\r\n\t}\r\n\treturn result\r\n}\r\n\r\n/**\r\n * Parses a viable phone number.\r\n * @param {string} formattedPhoneNumber — Example: \"(213) 373-4253\".\r\n * @param {string} [defaultCountry]\r\n * @param {string} [defaultCallingCode]\r\n * @param {Metadata} metadata\r\n * @return {object} Returns `{ country: string?, countryCallingCode: string?, nationalNumber: string? }`.\r\n */\r\nfunction parsePhoneNumber(\r\n\tformattedPhoneNumber,\r\n\tdefaultCountry,\r\n\tdefaultCallingCode,\r\n\tmetadata\r\n) {\r\n\t// Extract calling code from phone number.\r\n\tlet { countryCallingCode, number } = extractCountryCallingCode(\r\n\t\tparseIncompletePhoneNumber(formattedPhoneNumber),\r\n\t\tdefaultCountry,\r\n\t\tdefaultCallingCode,\r\n\t\tmetadata.metadata\r\n\t)\r\n\r\n\t// Choose a country by `countryCallingCode`.\r\n\tlet country\r\n\tif (countryCallingCode) {\r\n\t\tmetadata.selectNumberingPlan(countryCallingCode)\r\n\t}\r\n\t// If `formattedPhoneNumber` is in \"national\" format\r\n\t// then `number` is defined and `countryCallingCode` isn't.\r\n\telse if (number && (defaultCountry || defaultCallingCode)) {\r\n\t\tmetadata.selectNumberingPlan(defaultCountry, defaultCallingCode)\r\n\t\tif (defaultCountry) {\r\n\t\t\tcountry = defaultCountry\r\n\t\t} else {\r\n\t\t\t/* istanbul ignore if */\r\n\t\t\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\t\t\tif (metadata.isNonGeographicCallingCode(defaultCallingCode)) {\r\n\t\t\t\t\tcountry = '001'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tcountryCallingCode = defaultCallingCode || getCountryCallingCode(defaultCountry, metadata.metadata)\r\n\t}\r\n\telse return {}\r\n\r\n\tif (!number) {\r\n\t\treturn { countryCallingCode }\r\n\t}\r\n\r\n\tconst {\r\n\t\tnationalNumber,\r\n\t\tcarrierCode\r\n\t} = extractNationalNumber(\r\n\t\tparseIncompletePhoneNumber(number),\r\n\t\tmetadata\r\n\t)\r\n\r\n\t// Sometimes there are several countries\r\n\t// corresponding to the same country phone code\r\n\t// (e.g. NANPA countries all having `1` country phone code).\r\n\t// Therefore, to reliably determine the exact country,\r\n\t// national (significant) number should have been parsed first.\r\n\t//\r\n\t// When `metadata.json` is generated, all \"ambiguous\" country phone codes\r\n\t// get their countries populated with the full set of\r\n\t// \"phone number type\" regular expressions.\r\n\t//\r\n\tconst exactCountry = getCountryByCallingCode(countryCallingCode, nationalNumber, metadata)\r\n\tif (exactCountry) {\r\n\t\tcountry = exactCountry\r\n\t\t/* istanbul ignore if */\r\n\t\tif (exactCountry === '001') {\r\n\t\t\t// Can't happen with `USE_NON_GEOGRAPHIC_COUNTRY_CODE` being `false`.\r\n\t\t\t// If `USE_NON_GEOGRAPHIC_COUNTRY_CODE` is set to `true` for some reason,\r\n\t\t\t// then remove the \"istanbul ignore if\".\r\n\t\t} else {\r\n\t\t\tmetadata.country(country)\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode,\r\n\t\tnationalNumber,\r\n\t\tcarrierCode\r\n\t}\r\n}"]},"metadata":{},"sourceType":"module"}