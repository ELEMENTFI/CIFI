{"ast":null,"code":"import { parsePhoneNumberFromString, getCountryCallingCode, AsYouType, Metadata } from 'libphonenumber-js/core';\nimport getInternationalPhoneNumberPrefix from './getInternationalPhoneNumberPrefix';\n/**\r\n * Decides which country should be pre-selected\r\n * when the phone number input component is first mounted.\r\n * @param  {object?} phoneNumber - An instance of `PhoneNumber` class.\r\n * @param  {string?} country - Pre-defined country (two-letter code).\r\n * @param  {string[]?} countries - A list of countries available.\r\n * @param  {object} metadata - `libphonenumber-js` metadata\r\n * @return {string?}\r\n */\n\nexport function getPreSelectedCountry(_ref) {\n  var value = _ref.value,\n      phoneNumber = _ref.phoneNumber,\n      defaultCountry = _ref.defaultCountry,\n      getAnyCountry = _ref.getAnyCountry,\n      countries = _ref.countries,\n      required = _ref.required,\n      metadata = _ref.metadata;\n  var country; // If can get country from E.164 phone number\n  // then it overrides the `country` passed (or not passed).\n\n  if (phoneNumber && phoneNumber.country) {\n    // `country` will be left `undefined` in case of non-detection.\n    country = phoneNumber.country;\n  } else if (defaultCountry) {\n    if (!value || couldNumberBelongToCountry(value, defaultCountry, metadata)) {\n      country = defaultCountry;\n    }\n  } // Only pre-select a country if it's in the available `countries` list.\n\n\n  if (countries && countries.indexOf(country) < 0) {\n    country = undefined;\n  } // If there will be no \"International\" option\n  // then some `country` must be selected.\n  // It will still be the wrong country though.\n  // But still country `<select/>` can't be left in a broken state.\n\n\n  if (!country && required && countries && countries.length > 0) {\n    country = getAnyCountry(); // noCountryMatchesTheNumber = true\n  }\n\n  return country;\n}\n/**\r\n * Generates a sorted list of country `<select/>` options.\r\n * @param  {string[]} countries - A list of two-letter (\"ISO 3166-1 alpha-2\") country codes.\r\n * @param  {object} labels - Custom country labels. E.g. `{ RU: 'Россия', US: 'США', ... }`.\r\n * @param  {boolean} addInternationalOption - Whether should include \"International\" option at the top of the list.\r\n * @return {object[]} A list of objects having shape `{ value : string, label : string }`.\r\n */\n\nexport function getCountrySelectOptions(_ref2) {\n  var countries = _ref2.countries,\n      countryNames = _ref2.countryNames,\n      addInternationalOption = _ref2.addInternationalOption,\n      compareStringsLocales = _ref2.compareStringsLocales,\n      _compareStrings = _ref2.compareStrings; // Default country name comparator uses `String.localeCompare()`.\n\n  if (!_compareStrings) {\n    _compareStrings = compareStrings;\n  } // Generates a `<Select/>` option for each country.\n\n\n  var countrySelectOptions = countries.map(function (country) {\n    return {\n      value: country,\n      // All `locale` country names included in this library\n      // include all countries (this is checked at build time).\n      // The only case when a country name might be missing\n      // is when a developer supplies their own `labels` property.\n      // To guard against such cases, a missing country name\n      // is substituted by country code.\n      label: countryNames[country] || country\n    };\n  }); // Sort the list of countries alphabetically.\n\n  countrySelectOptions.sort(function (a, b) {\n    return _compareStrings(a.label, b.label, compareStringsLocales);\n  }); // Add the \"International\" option to the country list (if suitable)\n\n  if (addInternationalOption) {\n    countrySelectOptions.unshift({\n      label: countryNames.ZZ\n    });\n  }\n\n  return countrySelectOptions;\n}\n/**\r\n * Parses a E.164 phone number to an instance of `PhoneNumber` class.\r\n * @param {string?} value = E.164 phone number.\r\n * @param  {object} metadata - `libphonenumber-js` metadata\r\n * @return {object} Object having shape `{ country: string?, countryCallingCode: string, number: string }`. `PhoneNumber`: https://gitlab.com/catamphetamine/libphonenumber-js#phonenumber.\r\n * @example\r\n * parsePhoneNumber('+78005553535')\r\n */\n\nexport function parsePhoneNumber(value, metadata) {\n  return parsePhoneNumberFromString(value || '', metadata);\n}\n/**\r\n * Generates national number digits for a parsed phone.\r\n * May prepend national prefix.\r\n * The phone number must be a complete and valid phone number.\r\n * @param  {object} phoneNumber - An instance of `PhoneNumber` class.\r\n * @param  {object} metadata - `libphonenumber-js` metadata\r\n * @return {string}\r\n * @example\r\n * getNationalNumberDigits({ country: 'RU', phone: '8005553535' })\r\n * // returns '88005553535'\r\n */\n\nexport function generateNationalNumberDigits(phoneNumber) {\n  return phoneNumber.formatNational().replace(/\\D/g, '');\n}\n/**\r\n * Migrates parsed `<input/>` `value` for the newly selected `country`.\r\n * @param {string?} phoneDigits - Phone number digits (and `+`) parsed from phone number `<input/>` (it's not the same as the `value` property).\r\n * @param {string?} prevCountry - Previously selected country.\r\n * @param {string?} newCountry - Newly selected country. Can't be same as previously selected country.\r\n * @param {object} metadata - `libphonenumber-js` metadata.\r\n * @param {boolean} useNationalFormat - whether should attempt to convert from international to national number for the new country.\r\n * @return {string?}\r\n */\n\nexport function getPhoneDigitsForNewCountry(phoneDigits, _ref3) {\n  var prevCountry = _ref3.prevCountry,\n      newCountry = _ref3.newCountry,\n      metadata = _ref3.metadata,\n      useNationalFormat = _ref3.useNationalFormat; // If `parsed_input` is empty\n  // then no need to migrate anything.\n\n  if (!phoneDigits) {\n    if (useNationalFormat) {\n      return '';\n    } else {\n      // If `phoneDigits` is empty then set `phoneDigits` to\n      // `+{getCountryCallingCode(newCountry)}`.\n      return getInternationalPhoneNumberPrefix(newCountry, metadata);\n    }\n  } // If switching to some country.\n  // (from \"International\" or another country)\n  // If switching from \"International\" then `phoneDigits` starts with a `+`.\n  // Otherwise it may or may not start with a `+`.\n\n\n  if (newCountry) {\n    // If the phone number was entered in international format\n    // then migrate it to the newly selected country.\n    // The phone number may be incomplete.\n    // The phone number entered not necessarily starts with\n    // the previously selected country phone prefix.\n    if (phoneDigits[0] === '+') {\n      // If the international phone number is for the new country\n      // then convert it to local if required.\n      if (useNationalFormat) {\n        // // If a phone number is being input in international form\n        // // and the country can already be derived from it,\n        // // and if it is the new country, then format as a national number.\n        // const derived_country = getCountryFromPossiblyIncompleteInternationalPhoneNumber(phoneDigits, metadata)\n        // if (derived_country === newCountry) {\n        // \treturn stripCountryCallingCode(phoneDigits, derived_country, metadata)\n        // }\n        // Actually, the two countries don't necessarily need to match:\n        // the condition could be looser here, because several countries\n        // might share the same international phone number format\n        // (for example, \"NANPA\" countries like US, Canada, etc).\n        // The looser condition would be just \"same nternational phone number format\"\n        // which would mean \"same country calling code\" in the context of `libphonenumber-js`.\n        if (phoneDigits.indexOf('+' + getCountryCallingCode(newCountry, metadata)) === 0) {\n          return stripCountryCallingCode(phoneDigits, newCountry, metadata);\n        } // Simply discard the previously entered international phone number,\n        // because otherwise any \"smart\" transformation like getting the\n        // \"national (significant) number\" part and then prepending the\n        // newly selected country's \"country calling code\" to it\n        // would just be confusing for a user without being actually useful.\n\n\n        return ''; // // Simply strip the leading `+` character\n        // // therefore simply converting all digits into a \"local\" phone number.\n        // // https://github.com/catamphetamine/react-phone-number-input/issues/287\n        // return phoneDigits.slice(1)\n      }\n\n      if (prevCountry) {\n        var newCountryPrefix = getInternationalPhoneNumberPrefix(newCountry, metadata);\n\n        if (phoneDigits.indexOf(newCountryPrefix) === 0) {\n          return phoneDigits;\n        } else {\n          return newCountryPrefix;\n        }\n      } else {\n        var defaultValue = getInternationalPhoneNumberPrefix(newCountry, metadata); // If `phoneDigits`'s country calling code part is the same\n        // as for the new `country`, then leave `phoneDigits` as is.\n\n        if (phoneDigits.indexOf(defaultValue) === 0) {\n          return phoneDigits;\n        } // If `phoneDigits`'s country calling code part is not the same\n        // as for the new `country`, then set `phoneDigits` to\n        // `+{getCountryCallingCode(newCountry)}`.\n\n\n        return defaultValue;\n      } // // If the international phone number already contains\n      // // any country calling code then trim the country calling code part.\n      // // (that could also be the newly selected country phone code prefix as well)\n      // // `phoneDigits` doesn't neccessarily belong to `prevCountry`.\n      // // (e.g. if a user enters an international number\n      // //  not belonging to any of the reduced `countries` list).\n      // phoneDigits = stripCountryCallingCode(phoneDigits, prevCountry, metadata)\n      // // Prepend country calling code prefix\n      // // for the newly selected country.\n      // return e164(phoneDigits, newCountry, metadata) || `+${getCountryCallingCode(newCountry, metadata)}`\n\n    }\n  } // If switching to \"International\" from a country.\n  else {\n      // If the phone number was entered in national format.\n      if (phoneDigits[0] !== '+') {\n        // Format the national phone number as an international one.\n        // The phone number entered not necessarily even starts with\n        // the previously selected country phone prefix.\n        // Even if the phone number belongs to whole another country\n        // it will still be parsed into some national phone number.\n        return e164(phoneDigits, prevCountry, metadata) || '';\n      }\n    }\n\n  return phoneDigits;\n}\n/**\r\n * Converts phone number digits to a (possibly incomplete) E.164 phone number.\r\n * @param  {string?} number - A possibly incomplete phone number digits string. Can be a possibly incomplete E.164 phone number.\r\n * @param  {string?} country\r\n * @param  {[object} metadata - `libphonenumber-js` metadata.\r\n * @return {string?}\r\n */\n\nexport function e164(number, country, metadata) {\n  if (!number) {\n    return;\n  } // If the phone number is being input in international format.\n\n\n  if (number[0] === '+') {\n    // If it's just the `+` sign then return nothing.\n    if (number === '+') {\n      return;\n    } // If there are any digits then the `value` is returned as is.\n\n\n    return number;\n  } // For non-international phone numbers\n  // an accompanying country code is required.\n\n\n  if (!country) {\n    return;\n  }\n\n  var partial_national_significant_number = getNationalSignificantNumberDigits(number, country, metadata);\n\n  if (partial_national_significant_number) {\n    return \"+\".concat(getCountryCallingCode(country, metadata)).concat(partial_national_significant_number);\n  }\n}\n/**\r\n * Trims phone number digits if they exceed the maximum possible length\r\n * for a national (significant) number for the country.\r\n * @param  {string} number - A possibly incomplete phone number digits string. Can be a possibly incomplete E.164 phone number.\r\n * @param  {string} country\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string} Can be empty.\r\n */\n\nexport function trimNumber(number, country, metadata) {\n  var nationalSignificantNumberPart = getNationalSignificantNumberDigits(number, country, metadata);\n\n  if (nationalSignificantNumberPart) {\n    var overflowDigitsCount = nationalSignificantNumberPart.length - getMaxNumberLength(country, metadata);\n\n    if (overflowDigitsCount > 0) {\n      return number.slice(0, number.length - overflowDigitsCount);\n    }\n  }\n\n  return number;\n}\n\nfunction getMaxNumberLength(country, metadata) {\n  // Get \"possible lengths\" for a phone number of the country.\n  metadata = new Metadata(metadata);\n  metadata.country(country); // Return the last \"possible length\".\n\n  return metadata.numberingPlan.possibleLengths()[metadata.numberingPlan.possibleLengths().length - 1];\n} // If the phone number being input is an international one\n// then tries to derive the country from the phone number.\n// (regardless of whether there's any country currently selected)\n\n/**\r\n * @param {string} partialE164Number - A possibly incomplete E.164 phone number.\r\n * @param {string?} country - Currently selected country.\r\n * @param {string[]?} countries - A list of available countries. If not passed then \"all countries\" are assumed.\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string?}\r\n */\n\n\nexport function getCountryForPartialE164Number(partialE164Number, _ref4) {\n  var country = _ref4.country,\n      countries = _ref4.countries,\n      required = _ref4.required,\n      metadata = _ref4.metadata;\n\n  if (partialE164Number === '+') {\n    // Don't change the currently selected country yet.\n    return country;\n  }\n\n  var derived_country = getCountryFromPossiblyIncompleteInternationalPhoneNumber(partialE164Number, metadata); // If a phone number is being input in international form\n  // and the country can already be derived from it,\n  // then select that country.\n\n  if (derived_country && (!countries || countries.indexOf(derived_country) >= 0)) {\n    return derived_country;\n  } // If \"International\" country option has not been disabled\n  // and the international phone number entered doesn't correspond\n  // to the currently selected country then reset the currently selected country.\n  else if (country && !required && !couldNumberBelongToCountry(partialE164Number, country, metadata)) {\n      return undefined;\n    } // Don't change the currently selected country.\n\n\n  return country;\n}\n/**\r\n * Parses `<input/>` value. Derives `country` from `input`. Derives an E.164 `value`.\r\n * @param  {string?} phoneDigits — Parsed `<input/>` value. Examples: `\"\"`, `\"+\"`, `\"+123\"`, `\"123\"`.\r\n * @param  {string?} prevPhoneDigits — Previous parsed `<input/>` value. Examples: `\"\"`, `\"+\"`, `\"+123\"`, `\"123\"`.\r\n * @param  {string?} country - Currently selected country.\r\n * @param  {boolean} countryRequired - Is selecting some country required.\r\n * @param  {function} getAnyCountry - Can be used to get any country when selecting some country required.\r\n * @param  {string[]?} countries - A list of available countries. If not passed then \"all countries\" are assumed.\r\n * @param  {boolean} international - Set to `true` to force international phone number format (leading `+`). Set to `false` to force \"national\" phone number format. Is `undefined` by default.\r\n * @param  {boolean} limitMaxLength — Whether to enable limiting phone number max length.\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {object} An object of shape `{ input, country, value }`.\r\n */\n\nexport function onPhoneDigitsChange(phoneDigits, _ref5) {\n  var prevPhoneDigits = _ref5.prevPhoneDigits,\n      country = _ref5.country,\n      defaultCountry = _ref5.defaultCountry,\n      countryRequired = _ref5.countryRequired,\n      getAnyCountry = _ref5.getAnyCountry,\n      countries = _ref5.countries,\n      international = _ref5.international,\n      limitMaxLength = _ref5.limitMaxLength,\n      countryCallingCodeEditable = _ref5.countryCallingCodeEditable,\n      metadata = _ref5.metadata;\n\n  if (international && countryCallingCodeEditable === false) {\n    var prefix = getInternationalPhoneNumberPrefix(country, metadata); // The `<input/>` value must start with the country calling code.\n\n    if (phoneDigits.indexOf(prefix) !== 0) {\n      // If a user tabs into a phone number input field\n      // that is `international` and `withCountryCallingCode`,\n      // and then starts inputting local phone number digits,\n      // the first digit would get \"swallowed\" without this `appendDigits` fix.\n      // https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/43\n      if (phoneDigits && phoneDigits[0] !== '+') {\n        phoneDigits = prefix + phoneDigits;\n      } else {\n        phoneDigits = prefix;\n      }\n\n      return {\n        phoneDigits: phoneDigits,\n        value: undefined,\n        country: country\n      };\n    }\n  } // If `international` property is `false`, then it means\n  // \"enforce national-only format during input\",\n  // so, if that's the case, then remove all `+` characters,\n  // but only if some country is currently selected.\n  // (not if \"International\" country is selected).\n\n\n  if (international === false && country && phoneDigits && phoneDigits[0] === '+') {\n    phoneDigits = convertInternationalPhoneDigitsToNational(phoneDigits, country, metadata);\n  } // Trim the input to not exceed the maximum possible number length.\n\n\n  if (phoneDigits && country && limitMaxLength) {\n    phoneDigits = trimNumber(phoneDigits, country, metadata);\n  } // If this `onChange()` event was triggered\n  // as a result of selecting \"International\" country,\n  // then force-prepend a `+` sign if the phone number\n  // `<input/>` value isn't in international format.\n  // Also, force-prepend a `+` sign if international\n  // phone number input format is set.\n\n\n  if (phoneDigits && phoneDigits[0] !== '+' && (!country || international)) {\n    phoneDigits = '+' + phoneDigits;\n  } // If the previously entered phone number\n  // has been entered in international format\n  // and the user decides to erase it,\n  // then also reset the `country`\n  // because it was most likely automatically selected\n  // while the user was typing in the phone number\n  // in international format.\n  // This fixes the issue when a user is presented\n  // with a phone number input with no country selected\n  // and then types in their local phone number\n  // then discovers that the input's messed up\n  // (a `+` has been prepended at the start of their input\n  //  and a random country has been selected),\n  // decides to undo it all by erasing everything\n  // and then types in their local phone number again\n  // resulting in a seemingly correct phone number\n  // but in reality that phone number has incorrect country.\n  // https://github.com/catamphetamine/react-phone-number-input/issues/273\n\n\n  if (!phoneDigits && prevPhoneDigits && prevPhoneDigits[0] === '+') {\n    if (international) {\n      country = undefined;\n    } else {\n      country = defaultCountry;\n    }\n  } // Also resets such \"randomly\" selected country\n  // as soon as the user erases the number\n  // digit-by-digit up to the leading `+` sign.\n\n\n  if (phoneDigits === '+' && prevPhoneDigits && prevPhoneDigits[0] === '+' && prevPhoneDigits.length > '+'.length) {\n    country = undefined;\n  } // Generate the new `value` property.\n\n\n  var value;\n\n  if (phoneDigits) {\n    if (phoneDigits[0] === '+') {\n      if (phoneDigits === '+') {\n        value = undefined;\n      } else if (country && getInternationalPhoneNumberPrefix(country, metadata).indexOf(phoneDigits) === 0) {\n        value = undefined;\n      } else {\n        value = phoneDigits;\n      }\n    } else {\n      value = e164(phoneDigits, country, metadata);\n    }\n  } // Derive the country from the phone number.\n  // (regardless of whether there's any country currently selected,\n  //  because there could be several countries corresponding to one country calling code)\n\n\n  if (value) {\n    country = getCountryForPartialE164Number(value, {\n      country: country,\n      countries: countries,\n      metadata: metadata\n    }); // If `international` property is `false`, then it means\n    // \"enforce national-only format during input\",\n    // so, if that's the case, then remove all `+` characters,\n    // but only if some country is currently selected.\n    // (not if \"International\" country is selected).\n\n    if (international === false && country && phoneDigits && phoneDigits[0] === '+') {\n      phoneDigits = convertInternationalPhoneDigitsToNational(phoneDigits, country, metadata); // Re-calculate `value` because `phoneDigits` has changed.\n\n      value = e164(phoneDigits, country, metadata);\n    }\n  }\n\n  if (!country && countryRequired) {\n    country = defaultCountry || getAnyCountry();\n  }\n\n  return {\n    phoneDigits: phoneDigits,\n    country: country,\n    value: value\n  };\n}\n\nfunction convertInternationalPhoneDigitsToNational(input, country, metadata) {\n  // Handle the case when a user might have pasted\n  // a phone number in international format.\n  if (input.indexOf(getInternationalPhoneNumberPrefix(country, metadata)) === 0) {\n    // Create \"as you type\" formatter.\n    var formatter = new AsYouType(country, metadata); // Input partial national phone number.\n\n    formatter.input(input); // Return the parsed partial national phone number.\n\n    var phoneNumber = formatter.getNumber();\n\n    if (phoneNumber) {\n      // Transform the number to a national one,\n      // and remove all non-digits.\n      return phoneNumber.formatNational().replace(/\\D/g, '');\n    } else {\n      return '';\n    }\n  } else {\n    // Just remove the `+` sign.\n    return input.replace(/\\D/g, '');\n  }\n}\n/**\r\n * Determines the country for a given (possibly incomplete) E.164 phone number.\r\n * @param  {string} number - A possibly incomplete E.164 phone number.\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string?}\r\n */\n\n\nexport function getCountryFromPossiblyIncompleteInternationalPhoneNumber(number, metadata) {\n  var formatter = new AsYouType(null, metadata);\n  formatter.input(number); // // `001` is a special \"non-geograpical entity\" code\n  // // in Google's `libphonenumber` library.\n  // if (formatter.getCountry() === '001') {\n  // \treturn\n  // }\n\n  return formatter.getCountry();\n}\n/**\r\n * Compares two strings.\r\n * A helper for `Array.sort()`.\r\n * @param {string} a — First string.\r\n * @param {string} b — Second string.\r\n * @param {(string[]|string)} [locales] — The `locales` argument of `String.localeCompare`.\r\n */\n\nexport function compareStrings(a, b, locales) {\n  // Use `String.localeCompare` if it's available.\n  // https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare\n  // Which means everyone except IE <= 10 and Safari <= 10.\n  // `localeCompare()` is available in latest Node.js versions.\n\n  /* istanbul ignore else */\n  if (String.prototype.localeCompare) {\n    return a.localeCompare(b, locales);\n  }\n  /* istanbul ignore next */\n\n\n  return a < b ? -1 : a > b ? 1 : 0;\n}\n/**\r\n * Strips `+${countryCallingCode}` prefix from an E.164 phone number.\r\n * @param {string} number - (possibly incomplete) E.164 phone number.\r\n * @param {string?} country - A possible country for this phone number.\r\n * @param {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string}\r\n */\n\nexport function stripCountryCallingCode(number, country, metadata) {\n  // Just an optimization, so that it\n  // doesn't have to iterate through all country calling codes.\n  if (country) {\n    var countryCallingCodePrefix = '+' + getCountryCallingCode(country, metadata); // If `country` fits the actual `number`.\n\n    if (number.length < countryCallingCodePrefix.length) {\n      if (countryCallingCodePrefix.indexOf(number) === 0) {\n        return '';\n      }\n    } else {\n      if (number.indexOf(countryCallingCodePrefix) === 0) {\n        return number.slice(countryCallingCodePrefix.length);\n      }\n    }\n  } // If `country` doesn't fit the actual `number`.\n  // Try all available country calling codes.\n\n\n  for (var _i = 0, _Object$keys = Object.keys(metadata.country_calling_codes); _i < _Object$keys.length; _i++) {\n    var country_calling_code = _Object$keys[_i];\n\n    if (number.indexOf(country_calling_code) === '+'.length) {\n      return number.slice('+'.length + country_calling_code.length);\n    }\n  }\n\n  return '';\n}\n/**\r\n * Parses a partially entered national phone number digits\r\n * (or a partially entered E.164 international phone number)\r\n * and returns the national significant number part.\r\n * National significant number returned doesn't come with a national prefix.\r\n * @param {string} number - National number digits. Or possibly incomplete E.164 phone number.\r\n * @param {string?} country\r\n * @param {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string} [result]\r\n */\n\nexport function getNationalSignificantNumberDigits(number, country, metadata) {\n  // Create \"as you type\" formatter.\n  var formatter = new AsYouType(country, metadata); // Input partial national phone number.\n\n  formatter.input(number); // Return the parsed partial national phone number.\n\n  var phoneNumber = formatter.getNumber();\n  return phoneNumber && phoneNumber.nationalNumber;\n}\n/**\r\n * Checks if a partially entered E.164 phone number could belong to a country.\r\n * @param  {string} number\r\n * @param  {string} country\r\n * @return {boolean}\r\n */\n\nexport function couldNumberBelongToCountry(number, country, metadata) {\n  var intlPhoneNumberPrefix = getInternationalPhoneNumberPrefix(country, metadata);\n  var i = 0;\n\n  while (i < number.length && i < intlPhoneNumberPrefix.length) {\n    if (number[i] !== intlPhoneNumberPrefix[i]) {\n      return false;\n    }\n\n    i++;\n  }\n\n  return true;\n}\n/**\r\n * Gets initial \"phone digits\" (including `+`, if using international format).\r\n * @return {string} [phoneDigits] Returns `undefined` if there should be no initial \"phone digits\".\r\n */\n\nexport function getInitialPhoneDigits(_ref6) {\n  var value = _ref6.value,\n      phoneNumber = _ref6.phoneNumber,\n      defaultCountry = _ref6.defaultCountry,\n      international = _ref6.international,\n      useNationalFormat = _ref6.useNationalFormat,\n      metadata = _ref6.metadata; // If the `value` (E.164 phone number)\n  // belongs to the currently selected country\n  // and `useNationalFormat` is `true`\n  // then convert `value` (E.164 phone number)\n  // to a local phone number digits.\n  // E.g. '+78005553535' -> '88005553535'.\n\n  if ((international === false || useNationalFormat) && phoneNumber && phoneNumber.country) {\n    return generateNationalNumberDigits(phoneNumber);\n  } // If `international` property is `true`,\n  // meaning \"enforce international phone number format\",\n  // then always show country calling code in the input field.\n\n\n  if (!value && international && defaultCountry) {\n    return getInternationalPhoneNumberPrefix(defaultCountry, metadata);\n  }\n\n  return value;\n}","map":{"version":3,"sources":["../../source/helpers/phoneInputHelpers.js"],"names":["value","phoneNumber","defaultCountry","getAnyCountry","countries","required","metadata","country","couldNumberBelongToCountry","countryNames","addInternationalOption","compareStringsLocales","compareStrings","_compareStrings","countrySelectOptions","label","a","b","ZZ","parsePhoneNumberFromString","prevCountry","newCountry","useNationalFormat","getInternationalPhoneNumberPrefix","phoneDigits","getCountryCallingCode","stripCountryCallingCode","newCountryPrefix","defaultValue","e164","number","partial_national_significant_number","getNationalSignificantNumberDigits","nationalSignificantNumberPart","overflowDigitsCount","getMaxNumberLength","partialE164Number","derived_country","getCountryFromPossiblyIncompleteInternationalPhoneNumber","prevPhoneDigits","countryRequired","international","limitMaxLength","countryCallingCodeEditable","prefix","convertInternationalPhoneDigitsToNational","trimNumber","getCountryForPartialE164Number","input","formatter","String","countryCallingCodePrefix","country_calling_code","Object","intlPhoneNumberPrefix","i","generateNationalNumberDigits"],"mappings":"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","sourcesContent":["import {\r\n\tparsePhoneNumberFromString,\r\n\tgetCountryCallingCode,\r\n\tAsYouType,\r\n\tMetadata\r\n} from 'libphonenumber-js/core'\r\n\r\nimport getInternationalPhoneNumberPrefix from './getInternationalPhoneNumberPrefix'\r\n\r\n/**\r\n * Decides which country should be pre-selected\r\n * when the phone number input component is first mounted.\r\n * @param  {object?} phoneNumber - An instance of `PhoneNumber` class.\r\n * @param  {string?} country - Pre-defined country (two-letter code).\r\n * @param  {string[]?} countries - A list of countries available.\r\n * @param  {object} metadata - `libphonenumber-js` metadata\r\n * @return {string?}\r\n */\r\nexport function getPreSelectedCountry({\r\n\tvalue,\r\n\tphoneNumber,\r\n\tdefaultCountry,\r\n\tgetAnyCountry,\r\n\tcountries,\r\n\trequired,\r\n\tmetadata\r\n}) {\r\n\tlet country\r\n\r\n\t// If can get country from E.164 phone number\r\n\t// then it overrides the `country` passed (or not passed).\r\n\tif (phoneNumber && phoneNumber.country) {\r\n\t\t// `country` will be left `undefined` in case of non-detection.\r\n\t\tcountry = phoneNumber.country\r\n\t} else if (defaultCountry) {\r\n\t\tif (!value || couldNumberBelongToCountry(value, defaultCountry, metadata)) {\r\n\t\t\tcountry = defaultCountry\r\n\t\t}\r\n\t}\r\n\r\n\t// Only pre-select a country if it's in the available `countries` list.\r\n\tif (countries && countries.indexOf(country) < 0) {\r\n\t\tcountry = undefined\r\n\t}\r\n\r\n\t// If there will be no \"International\" option\r\n\t// then some `country` must be selected.\r\n\t// It will still be the wrong country though.\r\n\t// But still country `<select/>` can't be left in a broken state.\r\n\tif (!country && required && countries && countries.length > 0) {\r\n\t\tcountry = getAnyCountry()\r\n\t\t// noCountryMatchesTheNumber = true\r\n\t}\r\n\r\n\treturn country\r\n}\r\n\r\n/**\r\n * Generates a sorted list of country `<select/>` options.\r\n * @param  {string[]} countries - A list of two-letter (\"ISO 3166-1 alpha-2\") country codes.\r\n * @param  {object} labels - Custom country labels. E.g. `{ RU: 'Россия', US: 'США', ... }`.\r\n * @param  {boolean} addInternationalOption - Whether should include \"International\" option at the top of the list.\r\n * @return {object[]} A list of objects having shape `{ value : string, label : string }`.\r\n */\r\nexport function getCountrySelectOptions({\r\n\tcountries,\r\n\tcountryNames,\r\n\taddInternationalOption,\r\n\t// `locales` are only used in country name comparator:\r\n\t// depending on locale, string sorting order could be different.\r\n\tcompareStringsLocales,\r\n\tcompareStrings: _compareStrings\r\n}) {\r\n\t// Default country name comparator uses `String.localeCompare()`.\r\n\tif (!_compareStrings) {\r\n\t\t_compareStrings = compareStrings\r\n\t}\r\n\r\n\t// Generates a `<Select/>` option for each country.\r\n\tconst countrySelectOptions = countries.map((country) => ({\r\n\t\tvalue: country,\r\n\t\t// All `locale` country names included in this library\r\n\t\t// include all countries (this is checked at build time).\r\n\t\t// The only case when a country name might be missing\r\n\t\t// is when a developer supplies their own `labels` property.\r\n\t\t// To guard against such cases, a missing country name\r\n\t\t// is substituted by country code.\r\n\t\tlabel: countryNames[country] || country\r\n\t}))\r\n\r\n\t// Sort the list of countries alphabetically.\r\n\tcountrySelectOptions.sort((a, b) => _compareStrings(a.label, b.label, compareStringsLocales))\r\n\r\n\t// Add the \"International\" option to the country list (if suitable)\r\n\tif (addInternationalOption) {\r\n\t\tcountrySelectOptions.unshift({\r\n\t\t\tlabel: countryNames.ZZ\r\n\t\t})\r\n\t}\r\n\r\n\treturn countrySelectOptions\r\n}\r\n\r\n/**\r\n * Parses a E.164 phone number to an instance of `PhoneNumber` class.\r\n * @param {string?} value = E.164 phone number.\r\n * @param  {object} metadata - `libphonenumber-js` metadata\r\n * @return {object} Object having shape `{ country: string?, countryCallingCode: string, number: string }`. `PhoneNumber`: https://gitlab.com/catamphetamine/libphonenumber-js#phonenumber.\r\n * @example\r\n * parsePhoneNumber('+78005553535')\r\n */\r\nexport function parsePhoneNumber(value, metadata) {\r\n\treturn parsePhoneNumberFromString(value || '', metadata)\r\n}\r\n\r\n/**\r\n * Generates national number digits for a parsed phone.\r\n * May prepend national prefix.\r\n * The phone number must be a complete and valid phone number.\r\n * @param  {object} phoneNumber - An instance of `PhoneNumber` class.\r\n * @param  {object} metadata - `libphonenumber-js` metadata\r\n * @return {string}\r\n * @example\r\n * getNationalNumberDigits({ country: 'RU', phone: '8005553535' })\r\n * // returns '88005553535'\r\n */\r\nexport function generateNationalNumberDigits(phoneNumber) {\r\n\treturn phoneNumber.formatNational().replace(/\\D/g, '')\r\n}\r\n\r\n/**\r\n * Migrates parsed `<input/>` `value` for the newly selected `country`.\r\n * @param {string?} phoneDigits - Phone number digits (and `+`) parsed from phone number `<input/>` (it's not the same as the `value` property).\r\n * @param {string?} prevCountry - Previously selected country.\r\n * @param {string?} newCountry - Newly selected country. Can't be same as previously selected country.\r\n * @param {object} metadata - `libphonenumber-js` metadata.\r\n * @param {boolean} useNationalFormat - whether should attempt to convert from international to national number for the new country.\r\n * @return {string?}\r\n */\r\nexport function getPhoneDigitsForNewCountry(phoneDigits, {\r\n\tprevCountry,\r\n\tnewCountry,\r\n\tmetadata,\r\n\tuseNationalFormat\r\n}) {\r\n\t// If `parsed_input` is empty\r\n\t// then no need to migrate anything.\r\n\tif (!phoneDigits) {\r\n\t\tif (useNationalFormat) {\r\n\t\t\treturn ''\r\n\t\t} else {\r\n\t\t\t// If `phoneDigits` is empty then set `phoneDigits` to\r\n\t\t\t// `+{getCountryCallingCode(newCountry)}`.\r\n\t\t\treturn getInternationalPhoneNumberPrefix(newCountry, metadata)\r\n\t\t}\r\n\t}\r\n\r\n\t// If switching to some country.\r\n\t// (from \"International\" or another country)\r\n\t// If switching from \"International\" then `phoneDigits` starts with a `+`.\r\n\t// Otherwise it may or may not start with a `+`.\r\n\tif (newCountry) {\r\n\t\t// If the phone number was entered in international format\r\n\t\t// then migrate it to the newly selected country.\r\n\t\t// The phone number may be incomplete.\r\n\t\t// The phone number entered not necessarily starts with\r\n\t\t// the previously selected country phone prefix.\r\n\t\tif (phoneDigits[0] === '+') {\r\n\t\t\t// If the international phone number is for the new country\r\n\t\t\t// then convert it to local if required.\r\n\t\t\tif (useNationalFormat) {\r\n\t\t\t\t// // If a phone number is being input in international form\r\n\t\t\t\t// // and the country can already be derived from it,\r\n\t\t\t\t// // and if it is the new country, then format as a national number.\r\n\t\t\t\t// const derived_country = getCountryFromPossiblyIncompleteInternationalPhoneNumber(phoneDigits, metadata)\r\n\t\t\t\t// if (derived_country === newCountry) {\r\n\t\t\t\t// \treturn stripCountryCallingCode(phoneDigits, derived_country, metadata)\r\n\t\t\t\t// }\r\n\r\n\t\t\t\t// Actually, the two countries don't necessarily need to match:\r\n\t\t\t\t// the condition could be looser here, because several countries\r\n\t\t\t\t// might share the same international phone number format\r\n\t\t\t\t// (for example, \"NANPA\" countries like US, Canada, etc).\r\n\t\t\t\t// The looser condition would be just \"same nternational phone number format\"\r\n\t\t\t\t// which would mean \"same country calling code\" in the context of `libphonenumber-js`.\r\n\t\t\t\tif (phoneDigits.indexOf('+' + getCountryCallingCode(newCountry, metadata)) === 0) {\r\n\t\t\t\t\treturn stripCountryCallingCode(phoneDigits, newCountry, metadata)\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Simply discard the previously entered international phone number,\r\n\t\t\t\t// because otherwise any \"smart\" transformation like getting the\r\n\t\t\t\t// \"national (significant) number\" part and then prepending the\r\n\t\t\t\t// newly selected country's \"country calling code\" to it\r\n\t\t\t\t// would just be confusing for a user without being actually useful.\r\n\t\t\t\treturn ''\r\n\r\n\t\t\t\t// // Simply strip the leading `+` character\r\n\t\t\t\t// // therefore simply converting all digits into a \"local\" phone number.\r\n\t\t\t\t// // https://github.com/catamphetamine/react-phone-number-input/issues/287\r\n\t\t\t\t// return phoneDigits.slice(1)\r\n\t\t\t}\r\n\r\n\t\t\tif (prevCountry) {\r\n\t\t\t\tconst newCountryPrefix = getInternationalPhoneNumberPrefix(newCountry, metadata)\r\n\t\t\t\tif (phoneDigits.indexOf(newCountryPrefix) === 0) {\r\n\t\t\t\t\treturn phoneDigits\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn newCountryPrefix\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tconst defaultValue = getInternationalPhoneNumberPrefix(newCountry, metadata)\r\n\t\t\t\t// If `phoneDigits`'s country calling code part is the same\r\n\t\t\t\t// as for the new `country`, then leave `phoneDigits` as is.\r\n\t\t\t\tif (phoneDigits.indexOf(defaultValue) === 0) {\r\n\t\t\t\t\treturn phoneDigits\r\n\t\t\t\t}\r\n\t\t\t\t// If `phoneDigits`'s country calling code part is not the same\r\n\t\t\t\t// as for the new `country`, then set `phoneDigits` to\r\n\t\t\t\t// `+{getCountryCallingCode(newCountry)}`.\r\n\t\t\t\treturn defaultValue\r\n\t\t\t}\r\n\r\n\t\t\t// // If the international phone number already contains\r\n\t\t\t// // any country calling code then trim the country calling code part.\r\n\t\t\t// // (that could also be the newly selected country phone code prefix as well)\r\n\t\t\t// // `phoneDigits` doesn't neccessarily belong to `prevCountry`.\r\n\t\t\t// // (e.g. if a user enters an international number\r\n\t\t\t// //  not belonging to any of the reduced `countries` list).\r\n\t\t\t// phoneDigits = stripCountryCallingCode(phoneDigits, prevCountry, metadata)\r\n\r\n\t\t\t// // Prepend country calling code prefix\r\n\t\t\t// // for the newly selected country.\r\n\t\t\t// return e164(phoneDigits, newCountry, metadata) || `+${getCountryCallingCode(newCountry, metadata)}`\r\n\t\t}\r\n\t}\r\n\t// If switching to \"International\" from a country.\r\n\telse {\r\n\t\t// If the phone number was entered in national format.\r\n\t\tif (phoneDigits[0] !== '+') {\r\n\t\t\t// Format the national phone number as an international one.\r\n\t\t\t// The phone number entered not necessarily even starts with\r\n\t\t\t// the previously selected country phone prefix.\r\n\t\t\t// Even if the phone number belongs to whole another country\r\n\t\t\t// it will still be parsed into some national phone number.\r\n\t\t\treturn e164(phoneDigits, prevCountry, metadata) || ''\r\n\t\t}\r\n\t}\r\n\r\n\treturn phoneDigits\r\n}\r\n\r\n/**\r\n * Converts phone number digits to a (possibly incomplete) E.164 phone number.\r\n * @param  {string?} number - A possibly incomplete phone number digits string. Can be a possibly incomplete E.164 phone number.\r\n * @param  {string?} country\r\n * @param  {[object} metadata - `libphonenumber-js` metadata.\r\n * @return {string?}\r\n */\r\nexport function e164(number, country, metadata) {\r\n\tif (!number) {\r\n\t\treturn\r\n\t}\r\n\t// If the phone number is being input in international format.\r\n\tif (number[0] === '+') {\r\n\t\t// If it's just the `+` sign then return nothing.\r\n\t\tif (number === '+') {\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// If there are any digits then the `value` is returned as is.\r\n\t\treturn number\r\n\t}\r\n\t// For non-international phone numbers\r\n\t// an accompanying country code is required.\r\n\tif (!country) {\r\n\t\treturn\r\n\t}\r\n\tconst partial_national_significant_number = getNationalSignificantNumberDigits(number, country, metadata)\r\n\tif (partial_national_significant_number) {\r\n\t\treturn `+${getCountryCallingCode(country, metadata)}${partial_national_significant_number}`\r\n\t}\r\n}\r\n\r\n/**\r\n * Trims phone number digits if they exceed the maximum possible length\r\n * for a national (significant) number for the country.\r\n * @param  {string} number - A possibly incomplete phone number digits string. Can be a possibly incomplete E.164 phone number.\r\n * @param  {string} country\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string} Can be empty.\r\n */\r\nexport function trimNumber(number, country, metadata) {\r\n\tconst nationalSignificantNumberPart = getNationalSignificantNumberDigits(number, country, metadata)\r\n\tif (nationalSignificantNumberPart) {\r\n\t\tconst overflowDigitsCount = nationalSignificantNumberPart.length - getMaxNumberLength(country, metadata)\r\n\t\tif (overflowDigitsCount > 0) {\r\n\t\t\treturn number.slice(0, number.length - overflowDigitsCount)\r\n\t\t}\r\n\t}\r\n\treturn number\r\n}\r\n\r\nfunction getMaxNumberLength(country, metadata) {\r\n\t// Get \"possible lengths\" for a phone number of the country.\r\n\tmetadata = new Metadata(metadata)\r\n\tmetadata.country(country)\r\n\t// Return the last \"possible length\".\r\n\treturn metadata.numberingPlan.possibleLengths()[metadata.numberingPlan.possibleLengths().length - 1]\r\n}\r\n\r\n// If the phone number being input is an international one\r\n// then tries to derive the country from the phone number.\r\n// (regardless of whether there's any country currently selected)\r\n/**\r\n * @param {string} partialE164Number - A possibly incomplete E.164 phone number.\r\n * @param {string?} country - Currently selected country.\r\n * @param {string[]?} countries - A list of available countries. If not passed then \"all countries\" are assumed.\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string?}\r\n */\r\nexport function getCountryForPartialE164Number(partialE164Number, {\r\n\tcountry,\r\n\tcountries,\r\n\trequired,\r\n\tmetadata\r\n}) {\r\n\tif (partialE164Number === '+') {\r\n\t\t// Don't change the currently selected country yet.\r\n\t\treturn country\r\n\t}\r\n\r\n\tconst derived_country = getCountryFromPossiblyIncompleteInternationalPhoneNumber(partialE164Number, metadata)\r\n\r\n\t// If a phone number is being input in international form\r\n\t// and the country can already be derived from it,\r\n\t// then select that country.\r\n\tif (derived_country && (!countries || (countries.indexOf(derived_country) >= 0))) {\r\n\t\treturn derived_country\r\n\t}\r\n\t// If \"International\" country option has not been disabled\r\n\t// and the international phone number entered doesn't correspond\r\n\t// to the currently selected country then reset the currently selected country.\r\n\telse if (country &&\r\n\t\t!required &&\r\n\t\t!couldNumberBelongToCountry(partialE164Number, country, metadata)) {\r\n\t\treturn undefined\r\n\t}\r\n\r\n\t// Don't change the currently selected country.\r\n\treturn country\r\n}\r\n\r\n/**\r\n * Parses `<input/>` value. Derives `country` from `input`. Derives an E.164 `value`.\r\n * @param  {string?} phoneDigits — Parsed `<input/>` value. Examples: `\"\"`, `\"+\"`, `\"+123\"`, `\"123\"`.\r\n * @param  {string?} prevPhoneDigits — Previous parsed `<input/>` value. Examples: `\"\"`, `\"+\"`, `\"+123\"`, `\"123\"`.\r\n * @param  {string?} country - Currently selected country.\r\n * @param  {boolean} countryRequired - Is selecting some country required.\r\n * @param  {function} getAnyCountry - Can be used to get any country when selecting some country required.\r\n * @param  {string[]?} countries - A list of available countries. If not passed then \"all countries\" are assumed.\r\n * @param  {boolean} international - Set to `true` to force international phone number format (leading `+`). Set to `false` to force \"national\" phone number format. Is `undefined` by default.\r\n * @param  {boolean} limitMaxLength — Whether to enable limiting phone number max length.\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {object} An object of shape `{ input, country, value }`.\r\n */\r\nexport function onPhoneDigitsChange(phoneDigits, {\r\n\tprevPhoneDigits,\r\n\tcountry,\r\n\tdefaultCountry,\r\n\tcountryRequired,\r\n\tgetAnyCountry,\r\n\tcountries,\r\n\tinternational,\r\n\tlimitMaxLength,\r\n\tcountryCallingCodeEditable,\r\n\tmetadata\r\n}) {\r\n\tif (international && countryCallingCodeEditable === false) {\r\n\t\tconst prefix = getInternationalPhoneNumberPrefix(country, metadata)\r\n\t\t// The `<input/>` value must start with the country calling code.\r\n\t\tif (phoneDigits.indexOf(prefix) !== 0) {\r\n\t\t\t// If a user tabs into a phone number input field\r\n\t\t\t// that is `international` and `withCountryCallingCode`,\r\n\t\t\t// and then starts inputting local phone number digits,\r\n\t\t\t// the first digit would get \"swallowed\" without this `appendDigits` fix.\r\n\t\t\t// https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/43\r\n\t\t\tif (phoneDigits && phoneDigits[0] !== '+') {\r\n\t\t\t\tphoneDigits = prefix + phoneDigits\r\n\t\t\t} else {\r\n\t\t\t\tphoneDigits = prefix\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\tphoneDigits,\r\n\t\t\t\tvalue: undefined,\r\n\t\t\t\tcountry\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// If `international` property is `false`, then it means\r\n\t// \"enforce national-only format during input\",\r\n\t// so, if that's the case, then remove all `+` characters,\r\n\t// but only if some country is currently selected.\r\n\t// (not if \"International\" country is selected).\r\n\tif (international === false && country && phoneDigits && phoneDigits[0] === '+') {\r\n\t\tphoneDigits = convertInternationalPhoneDigitsToNational(phoneDigits, country, metadata)\r\n\t}\r\n\r\n\t// Trim the input to not exceed the maximum possible number length.\r\n\tif (phoneDigits && country && limitMaxLength) {\r\n\t\tphoneDigits = trimNumber(phoneDigits, country, metadata)\r\n\t}\r\n\r\n\t// If this `onChange()` event was triggered\r\n\t// as a result of selecting \"International\" country,\r\n\t// then force-prepend a `+` sign if the phone number\r\n\t// `<input/>` value isn't in international format.\r\n\t// Also, force-prepend a `+` sign if international\r\n\t// phone number input format is set.\r\n\tif (phoneDigits && phoneDigits[0] !== '+' && (!country || international)) {\r\n\t\tphoneDigits = '+' + phoneDigits\r\n\t}\r\n\r\n\t// If the previously entered phone number\r\n\t// has been entered in international format\r\n\t// and the user decides to erase it,\r\n\t// then also reset the `country`\r\n\t// because it was most likely automatically selected\r\n\t// while the user was typing in the phone number\r\n\t// in international format.\r\n\t// This fixes the issue when a user is presented\r\n\t// with a phone number input with no country selected\r\n\t// and then types in their local phone number\r\n\t// then discovers that the input's messed up\r\n\t// (a `+` has been prepended at the start of their input\r\n\t//  and a random country has been selected),\r\n\t// decides to undo it all by erasing everything\r\n\t// and then types in their local phone number again\r\n\t// resulting in a seemingly correct phone number\r\n\t// but in reality that phone number has incorrect country.\r\n\t// https://github.com/catamphetamine/react-phone-number-input/issues/273\r\n\tif (!phoneDigits && prevPhoneDigits && prevPhoneDigits[0] === '+') {\r\n\t\tif (international) {\r\n\t\t\tcountry = undefined\r\n\t\t} else {\r\n\t\t\tcountry = defaultCountry\r\n\t\t}\r\n\t}\r\n\t// Also resets such \"randomly\" selected country\r\n\t// as soon as the user erases the number\r\n\t// digit-by-digit up to the leading `+` sign.\r\n\tif (phoneDigits === '+' && prevPhoneDigits && prevPhoneDigits[0] === '+' && prevPhoneDigits.length > '+'.length) {\r\n\t\tcountry = undefined\r\n\t}\r\n\r\n\t// Generate the new `value` property.\r\n\tlet value\r\n\tif (phoneDigits) {\r\n\t\tif (phoneDigits[0] === '+') {\r\n\t\t\tif (phoneDigits === '+') {\r\n\t\t\t\tvalue = undefined\r\n\t\t\t} else if (country && getInternationalPhoneNumberPrefix(country, metadata).indexOf(phoneDigits) === 0) {\r\n\t\t\t\tvalue = undefined\r\n\t\t\t} else {\r\n\t\t\t\tvalue = phoneDigits\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvalue = e164(phoneDigits, country, metadata)\r\n\t\t}\r\n\t}\r\n\r\n\t// Derive the country from the phone number.\r\n\t// (regardless of whether there's any country currently selected,\r\n\t//  because there could be several countries corresponding to one country calling code)\r\n\tif (value) {\r\n\t\tcountry = getCountryForPartialE164Number(value, {\r\n\t\t\tcountry,\r\n\t\t\tcountries,\r\n\t\t\tmetadata\r\n\t\t})\r\n\t\t// If `international` property is `false`, then it means\r\n\t\t// \"enforce national-only format during input\",\r\n\t\t// so, if that's the case, then remove all `+` characters,\r\n\t\t// but only if some country is currently selected.\r\n\t\t// (not if \"International\" country is selected).\r\n\t\tif (international === false && country && phoneDigits && phoneDigits[0] === '+') {\r\n\t\t\tphoneDigits = convertInternationalPhoneDigitsToNational(phoneDigits, country, metadata)\r\n\t\t\t// Re-calculate `value` because `phoneDigits` has changed.\r\n\t\t\tvalue = e164(phoneDigits, country, metadata)\r\n\t\t}\r\n\t}\r\n\r\n\tif (!country && countryRequired) {\r\n\t\tcountry = defaultCountry || getAnyCountry()\r\n\t}\r\n\r\n\treturn {\r\n\t\tphoneDigits,\r\n\t\tcountry,\r\n\t\tvalue\r\n\t}\r\n}\r\n\r\nfunction convertInternationalPhoneDigitsToNational(input, country, metadata) {\r\n\t// Handle the case when a user might have pasted\r\n\t// a phone number in international format.\r\n\tif (input.indexOf(getInternationalPhoneNumberPrefix(country, metadata)) === 0) {\r\n\t\t// Create \"as you type\" formatter.\r\n\t\tconst formatter = new AsYouType(country, metadata)\r\n\t\t// Input partial national phone number.\r\n\t\tformatter.input(input)\r\n\t\t// Return the parsed partial national phone number.\r\n\t\tconst phoneNumber = formatter.getNumber()\r\n\t\tif (phoneNumber) {\r\n\t\t\t// Transform the number to a national one,\r\n\t\t\t// and remove all non-digits.\r\n\t\t\treturn phoneNumber.formatNational().replace(/\\D/g, '')\r\n\t\t} else {\r\n\t\t\treturn ''\r\n\t\t}\r\n\t} else {\r\n\t\t// Just remove the `+` sign.\r\n\t\treturn input.replace(/\\D/g, '')\r\n\t}\r\n}\r\n\r\n/**\r\n * Determines the country for a given (possibly incomplete) E.164 phone number.\r\n * @param  {string} number - A possibly incomplete E.164 phone number.\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string?}\r\n */\r\nexport function getCountryFromPossiblyIncompleteInternationalPhoneNumber(number, metadata) {\r\n\tconst formatter = new AsYouType(null, metadata)\r\n\tformatter.input(number)\r\n\t// // `001` is a special \"non-geograpical entity\" code\r\n\t// // in Google's `libphonenumber` library.\r\n\t// if (formatter.getCountry() === '001') {\r\n\t// \treturn\r\n\t// }\r\n\treturn formatter.getCountry()\r\n}\r\n\r\n/**\r\n * Compares two strings.\r\n * A helper for `Array.sort()`.\r\n * @param {string} a — First string.\r\n * @param {string} b — Second string.\r\n * @param {(string[]|string)} [locales] — The `locales` argument of `String.localeCompare`.\r\n */\r\nexport function compareStrings(a, b, locales) {\r\n  // Use `String.localeCompare` if it's available.\r\n  // https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare\r\n  // Which means everyone except IE <= 10 and Safari <= 10.\r\n  // `localeCompare()` is available in latest Node.js versions.\r\n  /* istanbul ignore else */\r\n  if (String.prototype.localeCompare) {\r\n    return a.localeCompare(b, locales);\r\n  }\r\n  /* istanbul ignore next */\r\n  return a < b ? -1 : (a > b ? 1 : 0);\r\n}\r\n\r\n/**\r\n * Strips `+${countryCallingCode}` prefix from an E.164 phone number.\r\n * @param {string} number - (possibly incomplete) E.164 phone number.\r\n * @param {string?} country - A possible country for this phone number.\r\n * @param {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string}\r\n */\r\nexport function stripCountryCallingCode(number, country, metadata) {\r\n\t// Just an optimization, so that it\r\n\t// doesn't have to iterate through all country calling codes.\r\n\tif (country) {\r\n\t\tconst countryCallingCodePrefix = '+' + getCountryCallingCode(country, metadata)\r\n\r\n\t\t// If `country` fits the actual `number`.\r\n\t\tif (number.length < countryCallingCodePrefix.length) {\r\n\t\t\tif (countryCallingCodePrefix.indexOf(number) === 0) {\r\n\t\t\t\treturn ''\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (number.indexOf(countryCallingCodePrefix) === 0) {\r\n\t\t\t\treturn number.slice(countryCallingCodePrefix.length)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// If `country` doesn't fit the actual `number`.\r\n\t// Try all available country calling codes.\r\n\tfor (const country_calling_code of Object.keys(metadata.country_calling_codes)) {\r\n\t\tif (number.indexOf(country_calling_code) === '+'.length) {\r\n\t\t\treturn number.slice('+'.length + country_calling_code.length)\r\n\t\t}\r\n\t}\r\n\r\n\treturn ''\r\n}\r\n\r\n/**\r\n * Parses a partially entered national phone number digits\r\n * (or a partially entered E.164 international phone number)\r\n * and returns the national significant number part.\r\n * National significant number returned doesn't come with a national prefix.\r\n * @param {string} number - National number digits. Or possibly incomplete E.164 phone number.\r\n * @param {string?} country\r\n * @param {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string} [result]\r\n */\r\nexport function getNationalSignificantNumberDigits(number, country, metadata) {\r\n\t// Create \"as you type\" formatter.\r\n\tconst formatter = new AsYouType(country, metadata)\r\n\t// Input partial national phone number.\r\n\tformatter.input(number)\r\n\t// Return the parsed partial national phone number.\r\n\tconst phoneNumber = formatter.getNumber()\r\n\treturn phoneNumber && phoneNumber.nationalNumber\r\n}\r\n\r\n/**\r\n * Checks if a partially entered E.164 phone number could belong to a country.\r\n * @param  {string} number\r\n * @param  {string} country\r\n * @return {boolean}\r\n */\r\nexport function couldNumberBelongToCountry(number, country, metadata) {\r\n\tconst intlPhoneNumberPrefix = getInternationalPhoneNumberPrefix(country, metadata)\r\n\tlet i = 0\r\n\twhile (i < number.length && i < intlPhoneNumberPrefix.length) {\r\n\t\tif (number[i] !== intlPhoneNumberPrefix[i]) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\treturn true\r\n}\r\n\r\n/**\r\n * Gets initial \"phone digits\" (including `+`, if using international format).\r\n * @return {string} [phoneDigits] Returns `undefined` if there should be no initial \"phone digits\".\r\n */\r\nexport function getInitialPhoneDigits({\r\n\tvalue,\r\n\tphoneNumber,\r\n\tdefaultCountry,\r\n\tinternational,\r\n\tuseNationalFormat,\r\n\tmetadata\r\n}) {\r\n\t// If the `value` (E.164 phone number)\r\n\t// belongs to the currently selected country\r\n\t// and `useNationalFormat` is `true`\r\n\t// then convert `value` (E.164 phone number)\r\n\t// to a local phone number digits.\r\n\t// E.g. '+78005553535' -> '88005553535'.\r\n\tif ((international === false || useNationalFormat) && phoneNumber && phoneNumber.country) {\r\n\t\treturn generateNationalNumberDigits(phoneNumber)\r\n\t}\r\n\t// If `international` property is `true`,\r\n\t// meaning \"enforce international phone number format\",\r\n\t// then always show country calling code in the input field.\r\n\tif (!value && international && defaultCountry) {\r\n\t\treturn getInternationalPhoneNumberPrefix(defaultCountry, metadata)\r\n\t}\r\n\treturn value\r\n}"]},"metadata":{},"sourceType":"module"}