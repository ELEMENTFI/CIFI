"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;

var _helpers = require("./helpers");

var _closeBraces = _interopRequireDefault(require("./closeBraces"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// Takes a `template` where character placeholders
// are denoted by 'x'es (e.g. 'x (xxx) xxx-xx-xx').
//
// Returns a function which takes `value` characters
// and returns the `template` filled with those characters.
// If the `template` can only be partially filled
// then it is cut off.
//
// If `should_close_braces` is `true`,
// then it will also make sure all dangling braces are closed,
// e.g. "8 (8" -> "8 (8  )" (iPhone style phone number input).
//
function _default(template) {
  var placeholder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';
  var should_close_braces = arguments.length > 2 ? arguments[2] : undefined;

  if (!template) {
    return function (value) {
      return {
        text: value
      };
    };
  }

  var characters_in_template = (0, _helpers.count_occurences)(placeholder, template);
  return function (value) {
    if (!value) {
      return {
        text: '',
        template: template
      };
    }

    var value_character_index = 0;
    var filled_in_template = ''; // Using `.split('')` here instead of normal `for ... of`
    // because the importing application doesn't neccessarily include an ES6 polyfill.
    // The `.split('')` approach discards "exotic" UTF-8 characters
    // (the ones consisting of four bytes)
    // but template placeholder characters don't fall into that range
    // and appending UTF-8 characters to a string in parts still works.

    for (var _iterator = template.split(''), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var character = _ref;

      if (character !== placeholder) {
        filled_in_template += character;
        continue;
      }

      filled_in_template += value[value_character_index];
      value_character_index++; // If the last available value character has been filled in,
      // then return the filled in template
      // (either trim the right part or retain it,
      //  if no more character placeholders in there)

      if (value_character_index === value.length) {
        // If there are more character placeholders
        // in the right part of the template
        // then simply trim it.
        if (value.length < characters_in_template) {
          break;
        }
      }
    }

    if (should_close_braces) {
      filled_in_template = (0, _closeBraces["default"])(filled_in_template, template);
    }

    return {
      text: filled_in_template,
      template: template
    };
  };
}
//# sourceMappingURL=templateFormatter.js.map