{"ast":null,"code":"var capability = require('./capability');\n\nvar inherits = require('inherits');\n\nvar stream = require('readable-stream');\n\nvar rStates = exports.readyStates = {\n  UNSENT: 0,\n  OPENED: 1,\n  HEADERS_RECEIVED: 2,\n  LOADING: 3,\n  DONE: 4\n};\n\nvar IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, fetchTimer) {\n  var self = this;\n  stream.Readable.call(self);\n  self._mode = mode;\n  self.headers = {};\n  self.rawHeaders = [];\n  self.trailers = {};\n  self.rawTrailers = []; // Fake the 'close' event, but only once 'end' fires\n\n  self.on('end', function () {\n    // The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n    process.nextTick(function () {\n      self.emit('close');\n    });\n  });\n\n  if (mode === 'fetch') {\n    self._fetchResponse = response;\n    self.url = response.url;\n    self.statusCode = response.status;\n    self.statusMessage = response.statusText;\n    response.headers.forEach(function (header, key) {\n      self.headers[key.toLowerCase()] = header;\n      self.rawHeaders.push(key, header);\n    });\n\n    if (capability.writableStream) {\n      var writable = new WritableStream({\n        write: function (chunk) {\n          return new Promise(function (resolve, reject) {\n            if (self._destroyed) {\n              reject();\n            } else if (self.push(Buffer.from(chunk))) {\n              resolve();\n            } else {\n              self._resumeFetch = resolve;\n            }\n          });\n        },\n        close: function () {\n          global.clearTimeout(fetchTimer);\n          if (!self._destroyed) self.push(null);\n        },\n        abort: function (err) {\n          if (!self._destroyed) self.emit('error', err);\n        }\n      });\n\n      try {\n        response.body.pipeTo(writable).catch(function (err) {\n          global.clearTimeout(fetchTimer);\n          if (!self._destroyed) self.emit('error', err);\n        });\n        return;\n      } catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this\n\n    } // fallback for when writableStream or pipeTo aren't available\n\n\n    var reader = response.body.getReader();\n\n    function read() {\n      reader.read().then(function (result) {\n        if (self._destroyed) return;\n\n        if (result.done) {\n          global.clearTimeout(fetchTimer);\n          self.push(null);\n          return;\n        }\n\n        self.push(Buffer.from(result.value));\n        read();\n      }).catch(function (err) {\n        global.clearTimeout(fetchTimer);\n        if (!self._destroyed) self.emit('error', err);\n      });\n    }\n\n    read();\n  } else {\n    self._xhr = xhr;\n    self._pos = 0;\n    self.url = xhr.responseURL;\n    self.statusCode = xhr.status;\n    self.statusMessage = xhr.statusText;\n    var headers = xhr.getAllResponseHeaders().split(/\\r?\\n/);\n    headers.forEach(function (header) {\n      var matches = header.match(/^([^:]+):\\s*(.*)/);\n\n      if (matches) {\n        var key = matches[1].toLowerCase();\n\n        if (key === 'set-cookie') {\n          if (self.headers[key] === undefined) {\n            self.headers[key] = [];\n          }\n\n          self.headers[key].push(matches[2]);\n        } else if (self.headers[key] !== undefined) {\n          self.headers[key] += ', ' + matches[2];\n        } else {\n          self.headers[key] = matches[2];\n        }\n\n        self.rawHeaders.push(matches[1], matches[2]);\n      }\n    });\n    self._charset = 'x-user-defined';\n\n    if (!capability.overrideMimeType) {\n      var mimeType = self.rawHeaders['mime-type'];\n\n      if (mimeType) {\n        var charsetMatch = mimeType.match(/;\\s*charset=([^;])(;|$)/);\n\n        if (charsetMatch) {\n          self._charset = charsetMatch[1].toLowerCase();\n        }\n      }\n\n      if (!self._charset) self._charset = 'utf-8'; // best guess\n    }\n  }\n};\n\ninherits(IncomingMessage, stream.Readable);\n\nIncomingMessage.prototype._read = function () {\n  var self = this;\n  var resolve = self._resumeFetch;\n\n  if (resolve) {\n    self._resumeFetch = null;\n    resolve();\n  }\n};\n\nIncomingMessage.prototype._onXHRProgress = function () {\n  var self = this;\n  var xhr = self._xhr;\n  var response = null;\n\n  switch (self._mode) {\n    case 'text':\n      response = xhr.responseText;\n\n      if (response.length > self._pos) {\n        var newData = response.substr(self._pos);\n\n        if (self._charset === 'x-user-defined') {\n          var buffer = Buffer.alloc(newData.length);\n\n          for (var i = 0; i < newData.length; i++) buffer[i] = newData.charCodeAt(i) & 0xff;\n\n          self.push(buffer);\n        } else {\n          self.push(newData, self._charset);\n        }\n\n        self._pos = response.length;\n      }\n\n      break;\n\n    case 'arraybuffer':\n      if (xhr.readyState !== rStates.DONE || !xhr.response) break;\n      response = xhr.response;\n      self.push(Buffer.from(new Uint8Array(response)));\n      break;\n\n    case 'moz-chunked-arraybuffer':\n      // take whole\n      response = xhr.response;\n      if (xhr.readyState !== rStates.LOADING || !response) break;\n      self.push(Buffer.from(new Uint8Array(response)));\n      break;\n\n    case 'ms-stream':\n      response = xhr.response;\n      if (xhr.readyState !== rStates.LOADING) break;\n      var reader = new global.MSStreamReader();\n\n      reader.onprogress = function () {\n        if (reader.result.byteLength > self._pos) {\n          self.push(Buffer.from(new Uint8Array(reader.result.slice(self._pos))));\n          self._pos = reader.result.byteLength;\n        }\n      };\n\n      reader.onload = function () {\n        self.push(null);\n      }; // reader.onerror = ??? // TODO: this\n\n\n      reader.readAsArrayBuffer(response);\n      break;\n  } // The ms-stream case handles end separately in reader.onload()\n\n\n  if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {\n    self.push(null);\n  }\n};","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/algosigner-react/CIFI/WebApp/NFTWebAPP/node_modules/stream-http/lib/response.js"],"names":["capability","require","inherits","stream","rStates","exports","readyStates","UNSENT","OPENED","HEADERS_RECEIVED","LOADING","DONE","IncomingMessage","xhr","response","mode","fetchTimer","self","Readable","call","_mode","headers","rawHeaders","trailers","rawTrailers","on","process","nextTick","emit","_fetchResponse","url","statusCode","status","statusMessage","statusText","forEach","header","key","toLowerCase","push","writableStream","writable","WritableStream","write","chunk","Promise","resolve","reject","_destroyed","Buffer","from","_resumeFetch","close","global","clearTimeout","abort","err","body","pipeTo","catch","e","reader","getReader","read","then","result","done","value","_xhr","_pos","responseURL","getAllResponseHeaders","split","matches","match","undefined","_charset","overrideMimeType","mimeType","charsetMatch","prototype","_read","_onXHRProgress","responseText","length","newData","substr","buffer","alloc","i","charCodeAt","readyState","Uint8Array","MSStreamReader","onprogress","byteLength","slice","onload","readAsArrayBuffer"],"mappings":"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","sourcesContent":["var capability = require('./capability')\r\nvar inherits = require('inherits')\r\nvar stream = require('readable-stream')\r\n\r\nvar rStates = exports.readyStates = {\r\n\tUNSENT: 0,\r\n\tOPENED: 1,\r\n\tHEADERS_RECEIVED: 2,\r\n\tLOADING: 3,\r\n\tDONE: 4\r\n}\r\n\r\nvar IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, fetchTimer) {\r\n\tvar self = this\r\n\tstream.Readable.call(self)\r\n\r\n\tself._mode = mode\r\n\tself.headers = {}\r\n\tself.rawHeaders = []\r\n\tself.trailers = {}\r\n\tself.rawTrailers = []\r\n\r\n\t// Fake the 'close' event, but only once 'end' fires\r\n\tself.on('end', function () {\r\n\t\t// The nextTick is necessary to prevent the 'request' module from causing an infinite loop\r\n\t\tprocess.nextTick(function () {\r\n\t\t\tself.emit('close')\r\n\t\t})\r\n\t})\r\n\r\n\tif (mode === 'fetch') {\r\n\t\tself._fetchResponse = response\r\n\r\n\t\tself.url = response.url\r\n\t\tself.statusCode = response.status\r\n\t\tself.statusMessage = response.statusText\r\n\t\t\r\n\t\tresponse.headers.forEach(function (header, key){\r\n\t\t\tself.headers[key.toLowerCase()] = header\r\n\t\t\tself.rawHeaders.push(key, header)\r\n\t\t})\r\n\r\n\t\tif (capability.writableStream) {\r\n\t\t\tvar writable = new WritableStream({\r\n\t\t\t\twrite: function (chunk) {\r\n\t\t\t\t\treturn new Promise(function (resolve, reject) {\r\n\t\t\t\t\t\tif (self._destroyed) {\r\n\t\t\t\t\t\t\treject()\r\n\t\t\t\t\t\t} else if(self.push(Buffer.from(chunk))) {\r\n\t\t\t\t\t\t\tresolve()\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tself._resumeFetch = resolve\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t},\r\n\t\t\t\tclose: function () {\r\n\t\t\t\t\tglobal.clearTimeout(fetchTimer)\r\n\t\t\t\t\tif (!self._destroyed)\r\n\t\t\t\t\t\tself.push(null)\r\n\t\t\t\t},\r\n\t\t\t\tabort: function (err) {\r\n\t\t\t\t\tif (!self._destroyed)\r\n\t\t\t\t\t\tself.emit('error', err)\r\n\t\t\t\t}\r\n\t\t\t})\r\n\r\n\t\t\ttry {\r\n\t\t\t\tresponse.body.pipeTo(writable).catch(function (err) {\r\n\t\t\t\t\tglobal.clearTimeout(fetchTimer)\r\n\t\t\t\t\tif (!self._destroyed)\r\n\t\t\t\t\t\tself.emit('error', err)\r\n\t\t\t\t})\r\n\t\t\t\treturn\r\n\t\t\t} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this\r\n\t\t}\r\n\t\t// fallback for when writableStream or pipeTo aren't available\r\n\t\tvar reader = response.body.getReader()\r\n\t\tfunction read () {\r\n\t\t\treader.read().then(function (result) {\r\n\t\t\t\tif (self._destroyed)\r\n\t\t\t\t\treturn\r\n\t\t\t\tif (result.done) {\r\n\t\t\t\t\tglobal.clearTimeout(fetchTimer)\r\n\t\t\t\t\tself.push(null)\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tself.push(Buffer.from(result.value))\r\n\t\t\t\tread()\r\n\t\t\t}).catch(function (err) {\r\n\t\t\t\tglobal.clearTimeout(fetchTimer)\r\n\t\t\t\tif (!self._destroyed)\r\n\t\t\t\t\tself.emit('error', err)\r\n\t\t\t})\r\n\t\t}\r\n\t\tread()\r\n\t} else {\r\n\t\tself._xhr = xhr\r\n\t\tself._pos = 0\r\n\r\n\t\tself.url = xhr.responseURL\r\n\t\tself.statusCode = xhr.status\r\n\t\tself.statusMessage = xhr.statusText\r\n\t\tvar headers = xhr.getAllResponseHeaders().split(/\\r?\\n/)\r\n\t\theaders.forEach(function (header) {\r\n\t\t\tvar matches = header.match(/^([^:]+):\\s*(.*)/)\r\n\t\t\tif (matches) {\r\n\t\t\t\tvar key = matches[1].toLowerCase()\r\n\t\t\t\tif (key === 'set-cookie') {\r\n\t\t\t\t\tif (self.headers[key] === undefined) {\r\n\t\t\t\t\t\tself.headers[key] = []\r\n\t\t\t\t\t}\r\n\t\t\t\t\tself.headers[key].push(matches[2])\r\n\t\t\t\t} else if (self.headers[key] !== undefined) {\r\n\t\t\t\t\tself.headers[key] += ', ' + matches[2]\r\n\t\t\t\t} else {\r\n\t\t\t\t\tself.headers[key] = matches[2]\r\n\t\t\t\t}\r\n\t\t\t\tself.rawHeaders.push(matches[1], matches[2])\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\tself._charset = 'x-user-defined'\r\n\t\tif (!capability.overrideMimeType) {\r\n\t\t\tvar mimeType = self.rawHeaders['mime-type']\r\n\t\t\tif (mimeType) {\r\n\t\t\t\tvar charsetMatch = mimeType.match(/;\\s*charset=([^;])(;|$)/)\r\n\t\t\t\tif (charsetMatch) {\r\n\t\t\t\t\tself._charset = charsetMatch[1].toLowerCase()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!self._charset)\r\n\t\t\t\tself._charset = 'utf-8' // best guess\r\n\t\t}\r\n\t}\r\n}\r\n\r\ninherits(IncomingMessage, stream.Readable)\r\n\r\nIncomingMessage.prototype._read = function () {\r\n\tvar self = this\r\n\r\n\tvar resolve = self._resumeFetch\r\n\tif (resolve) {\r\n\t\tself._resumeFetch = null\r\n\t\tresolve()\r\n\t}\r\n}\r\n\r\nIncomingMessage.prototype._onXHRProgress = function () {\r\n\tvar self = this\r\n\r\n\tvar xhr = self._xhr\r\n\r\n\tvar response = null\r\n\tswitch (self._mode) {\r\n\t\tcase 'text':\r\n\t\t\tresponse = xhr.responseText\r\n\t\t\tif (response.length > self._pos) {\r\n\t\t\t\tvar newData = response.substr(self._pos)\r\n\t\t\t\tif (self._charset === 'x-user-defined') {\r\n\t\t\t\t\tvar buffer = Buffer.alloc(newData.length)\r\n\t\t\t\t\tfor (var i = 0; i < newData.length; i++)\r\n\t\t\t\t\t\tbuffer[i] = newData.charCodeAt(i) & 0xff\r\n\r\n\t\t\t\t\tself.push(buffer)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tself.push(newData, self._charset)\r\n\t\t\t\t}\r\n\t\t\t\tself._pos = response.length\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\tcase 'arraybuffer':\r\n\t\t\tif (xhr.readyState !== rStates.DONE || !xhr.response)\r\n\t\t\t\tbreak\r\n\t\t\tresponse = xhr.response\r\n\t\t\tself.push(Buffer.from(new Uint8Array(response)))\r\n\t\t\tbreak\r\n\t\tcase 'moz-chunked-arraybuffer': // take whole\r\n\t\t\tresponse = xhr.response\r\n\t\t\tif (xhr.readyState !== rStates.LOADING || !response)\r\n\t\t\t\tbreak\r\n\t\t\tself.push(Buffer.from(new Uint8Array(response)))\r\n\t\t\tbreak\r\n\t\tcase 'ms-stream':\r\n\t\t\tresponse = xhr.response\r\n\t\t\tif (xhr.readyState !== rStates.LOADING)\r\n\t\t\t\tbreak\r\n\t\t\tvar reader = new global.MSStreamReader()\r\n\t\t\treader.onprogress = function () {\r\n\t\t\t\tif (reader.result.byteLength > self._pos) {\r\n\t\t\t\t\tself.push(Buffer.from(new Uint8Array(reader.result.slice(self._pos))))\r\n\t\t\t\t\tself._pos = reader.result.byteLength\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treader.onload = function () {\r\n\t\t\t\tself.push(null)\r\n\t\t\t}\r\n\t\t\t// reader.onerror = ??? // TODO: this\r\n\t\t\treader.readAsArrayBuffer(response)\r\n\t\t\tbreak\r\n\t}\r\n\r\n\t// The ms-stream case handles end separately in reader.onload()\r\n\tif (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {\r\n\t\tself.push(null)\r\n\t}\r\n}\r\n"]},"metadata":{},"sourceType":"script"}