{"ast":null,"code":"'use strict';\n\nconst multihashing = require('multihashing-async');\n\nconst protobuf = require('protons');\n\nconst bs58 = require('bs58');\n\nconst nextTick = require('async/nextTick');\n\nconst crypto = require('./rsa');\n\nconst pbm = protobuf(require('./keys.proto'));\n\nrequire('node-forge/lib/sha512');\n\nrequire('node-forge/lib/pbe');\n\nconst forge = require('node-forge/lib/forge');\n\nclass RsaPublicKey {\n  constructor(key) {\n    this._key = key;\n  }\n\n  verify(data, sig, callback) {\n    ensure(callback);\n    crypto.hashAndVerify(this._key, sig, data, callback);\n  }\n\n  marshal() {\n    return crypto.utils.jwkToPkix(this._key);\n  }\n\n  get bytes() {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    });\n  }\n\n  encrypt(bytes, cb) {\n    return cbWrap(() => crypto.encrypt(this._key, bytes), cb);\n  }\n\n  equals(key) {\n    return this.bytes.equals(key.bytes);\n  }\n\n  hash(callback) {\n    ensure(callback);\n    multihashing(this.bytes, 'sha2-256', callback);\n  }\n\n}\n\nfunction cbWrap(f, cb) {\n  let res;\n\n  try {\n    res = f();\n  } catch (err) {\n    cb(err);\n  }\n\n  return cb(null, res);\n}\n\nclass RsaPrivateKey {\n  // key       - Object of the jwk format\n  // publicKey - Buffer of the spki format\n  constructor(key, publicKey) {\n    this._key = key;\n    this._publicKey = publicKey;\n  }\n\n  genSecret() {\n    return crypto.getRandomValues(16);\n  }\n\n  sign(message, callback) {\n    ensure(callback);\n    crypto.hashAndSign(this._key, message, callback);\n  }\n\n  get public() {\n    if (!this._publicKey) {\n      throw new Error('public key not provided');\n    }\n\n    return new RsaPublicKey(this._publicKey);\n  }\n\n  decrypt(bytes, cb) {\n    cbWrap(() => crypto.decrypt(this._key, bytes), cb);\n  }\n\n  marshal() {\n    return crypto.utils.jwkToPkcs1(this._key);\n  }\n\n  get bytes() {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    });\n  }\n\n  equals(key) {\n    return this.bytes.equals(key.bytes);\n  }\n\n  hash(callback) {\n    ensure(callback);\n    multihashing(this.bytes, 'sha2-256', callback);\n  }\n  /**\r\n   * Gets the ID of the key.\r\n   *\r\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\r\n   * The public key is a protobuf encoding containing a type and the DER encoding\r\n   * of the PKCS SubjectPublicKeyInfo.\r\n   *\r\n   * @param {function(Error, id)} callback\r\n   * @returns {undefined}\r\n   */\n\n\n  id(callback) {\n    this.public.hash((err, hash) => {\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, bs58.encode(hash));\n    });\n  }\n  /**\r\n   * Exports the key into a password protected PEM format\r\n   *\r\n   * @param {string} [format] - Defaults to 'pkcs-8'.\r\n   * @param {string} password - The password to read the encrypted PEM\r\n   * @param {function(Error, KeyInfo)} callback\r\n   * @returns {undefined}\r\n   */\n\n\n  export(format, password, callback) {\n    if (typeof password === 'function') {\n      callback = password;\n      password = format;\n      format = 'pkcs-8';\n    }\n\n    ensure(callback);\n    nextTick(() => {\n      let err = null;\n      let pem = null;\n\n      try {\n        const buffer = new forge.util.ByteBuffer(this.marshal());\n        const asn1 = forge.asn1.fromDer(buffer);\n        const privateKey = forge.pki.privateKeyFromAsn1(asn1);\n\n        if (format === 'pkcs-8') {\n          const options = {\n            algorithm: 'aes256',\n            count: 10000,\n            saltSize: 128 / 8,\n            prfAlgorithm: 'sha512'\n          };\n          pem = forge.pki.encryptRsaPrivateKey(privateKey, password, options);\n        } else {\n          err = new Error(`Unknown export format '${format}'`);\n        }\n      } catch (_err) {\n        err = _err;\n      }\n\n      callback(err, pem);\n    });\n  }\n\n}\n\nfunction unmarshalRsaPrivateKey(bytes, callback) {\n  const jwk = crypto.utils.pkcs1ToJwk(bytes);\n  crypto.unmarshalPrivateKey(jwk, (err, keys) => {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey));\n  });\n}\n\nfunction unmarshalRsaPublicKey(bytes) {\n  const jwk = crypto.utils.pkixToJwk(bytes);\n  return new RsaPublicKey(jwk);\n}\n\nfunction fromJwk(jwk, callback) {\n  crypto.unmarshalPrivateKey(jwk, (err, keys) => {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey));\n  });\n}\n\nfunction generateKeyPair(bits, callback) {\n  crypto.generateKey(bits, (err, keys) => {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey));\n  });\n}\n\nfunction ensure(callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n}\n\nmodule.exports = {\n  RsaPublicKey,\n  RsaPrivateKey,\n  unmarshalRsaPublicKey,\n  unmarshalRsaPrivateKey,\n  generateKeyPair,\n  fromJwk\n};","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/algosigner-react/CIFI/WebApp/NFTWebAPP/node_modules/peer-id/node_modules/libp2p-crypto/src/keys/rsa-class.js"],"names":["multihashing","require","protobuf","bs58","nextTick","crypto","pbm","forge","RsaPublicKey","constructor","key","_key","verify","data","sig","callback","ensure","hashAndVerify","marshal","utils","jwkToPkix","bytes","PublicKey","encode","Type","KeyType","RSA","Data","encrypt","cb","cbWrap","equals","hash","f","res","err","RsaPrivateKey","publicKey","_publicKey","genSecret","getRandomValues","sign","message","hashAndSign","public","Error","decrypt","jwkToPkcs1","PrivateKey","id","export","format","password","pem","buffer","util","ByteBuffer","asn1","fromDer","privateKey","pki","privateKeyFromAsn1","options","algorithm","count","saltSize","prfAlgorithm","encryptRsaPrivateKey","_err","unmarshalRsaPrivateKey","jwk","pkcs1ToJwk","unmarshalPrivateKey","keys","unmarshalRsaPublicKey","pkixToJwk","fromJwk","generateKeyPair","bits","generateKey","module","exports"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nconst multihashing = require('multihashing-async')\r\nconst protobuf = require('protons')\r\nconst bs58 = require('bs58')\r\nconst nextTick = require('async/nextTick')\r\n\r\nconst crypto = require('./rsa')\r\nconst pbm = protobuf(require('./keys.proto'))\r\nrequire('node-forge/lib/sha512')\r\nrequire('node-forge/lib/pbe')\r\nconst forge = require('node-forge/lib/forge')\r\n\r\nclass RsaPublicKey {\r\n  constructor (key) {\r\n    this._key = key\r\n  }\r\n\r\n  verify (data, sig, callback) {\r\n    ensure(callback)\r\n    crypto.hashAndVerify(this._key, sig, data, callback)\r\n  }\r\n\r\n  marshal () {\r\n    return crypto.utils.jwkToPkix(this._key)\r\n  }\r\n\r\n  get bytes () {\r\n    return pbm.PublicKey.encode({\r\n      Type: pbm.KeyType.RSA,\r\n      Data: this.marshal()\r\n    })\r\n  }\r\n\r\n  encrypt (bytes, cb) {\r\n    return cbWrap(() => crypto.encrypt(this._key, bytes), cb)\r\n  }\r\n\r\n  equals (key) {\r\n    return this.bytes.equals(key.bytes)\r\n  }\r\n\r\n  hash (callback) {\r\n    ensure(callback)\r\n    multihashing(this.bytes, 'sha2-256', callback)\r\n  }\r\n}\r\n\r\nfunction cbWrap (f, cb) {\r\n  let res\r\n  try {\r\n    res = f()\r\n  } catch (err) {\r\n    cb(err)\r\n  }\r\n\r\n  return cb(null, res)\r\n}\r\n\r\nclass RsaPrivateKey {\r\n  // key       - Object of the jwk format\r\n  // publicKey - Buffer of the spki format\r\n  constructor (key, publicKey) {\r\n    this._key = key\r\n    this._publicKey = publicKey\r\n  }\r\n\r\n  genSecret () {\r\n    return crypto.getRandomValues(16)\r\n  }\r\n\r\n  sign (message, callback) {\r\n    ensure(callback)\r\n    crypto.hashAndSign(this._key, message, callback)\r\n  }\r\n\r\n  get public () {\r\n    if (!this._publicKey) {\r\n      throw new Error('public key not provided')\r\n    }\r\n\r\n    return new RsaPublicKey(this._publicKey)\r\n  }\r\n\r\n  decrypt (bytes, cb) {\r\n    cbWrap(() => crypto.decrypt(this._key, bytes), cb)\r\n  }\r\n\r\n  marshal () {\r\n    return crypto.utils.jwkToPkcs1(this._key)\r\n  }\r\n\r\n  get bytes () {\r\n    return pbm.PrivateKey.encode({\r\n      Type: pbm.KeyType.RSA,\r\n      Data: this.marshal()\r\n    })\r\n  }\r\n\r\n  equals (key) {\r\n    return this.bytes.equals(key.bytes)\r\n  }\r\n\r\n  hash (callback) {\r\n    ensure(callback)\r\n    multihashing(this.bytes, 'sha2-256', callback)\r\n  }\r\n\r\n  /**\r\n   * Gets the ID of the key.\r\n   *\r\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\r\n   * The public key is a protobuf encoding containing a type and the DER encoding\r\n   * of the PKCS SubjectPublicKeyInfo.\r\n   *\r\n   * @param {function(Error, id)} callback\r\n   * @returns {undefined}\r\n   */\r\n  id (callback) {\r\n    this.public.hash((err, hash) => {\r\n      if (err) {\r\n        return callback(err)\r\n      }\r\n      callback(null, bs58.encode(hash))\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Exports the key into a password protected PEM format\r\n   *\r\n   * @param {string} [format] - Defaults to 'pkcs-8'.\r\n   * @param {string} password - The password to read the encrypted PEM\r\n   * @param {function(Error, KeyInfo)} callback\r\n   * @returns {undefined}\r\n   */\r\n  export (format, password, callback) {\r\n    if (typeof password === 'function') {\r\n      callback = password\r\n      password = format\r\n      format = 'pkcs-8'\r\n    }\r\n\r\n    ensure(callback)\r\n\r\n    nextTick(() => {\r\n      let err = null\r\n      let pem = null\r\n      try {\r\n        const buffer = new forge.util.ByteBuffer(this.marshal())\r\n        const asn1 = forge.asn1.fromDer(buffer)\r\n        const privateKey = forge.pki.privateKeyFromAsn1(asn1)\r\n        if (format === 'pkcs-8') {\r\n          const options = {\r\n            algorithm: 'aes256',\r\n            count: 10000,\r\n            saltSize: 128 / 8,\r\n            prfAlgorithm: 'sha512'\r\n          }\r\n          pem = forge.pki.encryptRsaPrivateKey(privateKey, password, options)\r\n        } else {\r\n          err = new Error(`Unknown export format '${format}'`)\r\n        }\r\n      } catch (_err) {\r\n        err = _err\r\n      }\r\n\r\n      callback(err, pem)\r\n    })\r\n  }\r\n}\r\n\r\nfunction unmarshalRsaPrivateKey (bytes, callback) {\r\n  const jwk = crypto.utils.pkcs1ToJwk(bytes)\r\n\r\n  crypto.unmarshalPrivateKey(jwk, (err, keys) => {\r\n    if (err) {\r\n      return callback(err)\r\n    }\r\n\r\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey))\r\n  })\r\n}\r\n\r\nfunction unmarshalRsaPublicKey (bytes) {\r\n  const jwk = crypto.utils.pkixToJwk(bytes)\r\n\r\n  return new RsaPublicKey(jwk)\r\n}\r\n\r\nfunction fromJwk (jwk, callback) {\r\n  crypto.unmarshalPrivateKey(jwk, (err, keys) => {\r\n    if (err) {\r\n      return callback(err)\r\n    }\r\n\r\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey))\r\n  })\r\n}\r\n\r\nfunction generateKeyPair (bits, callback) {\r\n  crypto.generateKey(bits, (err, keys) => {\r\n    if (err) {\r\n      return callback(err)\r\n    }\r\n\r\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey))\r\n  })\r\n}\r\n\r\nfunction ensure (callback) {\r\n  if (typeof callback !== 'function') {\r\n    throw new Error('callback is required')\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  RsaPublicKey,\r\n  RsaPrivateKey,\r\n  unmarshalRsaPublicKey,\r\n  unmarshalRsaPrivateKey,\r\n  generateKeyPair,\r\n  fromJwk\r\n}\r\n"]},"metadata":{},"sourceType":"script"}