{"version":3,"sources":["../source/templateFormatter.js"],"names":["template","placeholder","should_close_braces","value","text","characters_in_template","value_character_index","filled_in_template","split","character","length"],"mappings":";;;;;;;AAAA;;AACA;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,kBAASA,QAAT,EACf;AAAA,MADkCC,WAClC,uEADgD,GAChD;AAAA,MADqDC,mBACrD;;AACC,MAAI,CAACF,QAAL,EACA;AACC,WAAO,UAAAG,KAAK;AAAA,aAAK;AAAEC,QAAAA,IAAI,EAAED;AAAR,OAAL;AAAA,KAAZ;AACA;;AAED,MAAME,sBAAsB,GAAG,+BAAiBJ,WAAjB,EAA8BD,QAA9B,CAA/B;AAEA,SAAO,UAASG,KAAT,EACP;AACC,QAAI,CAACA,KAAL,EACA;AACC,aAAO;AAAEC,QAAAA,IAAI,EAAE,EAAR;AAAYJ,QAAAA,QAAQ,EAARA;AAAZ,OAAP;AACA;;AAED,QAAIM,qBAAqB,GAAG,CAA5B;AACA,QAAIC,kBAAkB,GAAG,EAAzB,CAPD,CASC;AACA;AACA;AACA;AACA;AACA;;AACA,yBAAwBP,QAAQ,CAACQ,KAAT,CAAe,EAAf,CAAxB,kHACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,UADWC,SACX;;AACC,UAAIA,SAAS,KAAKR,WAAlB,EACA;AACCM,QAAAA,kBAAkB,IAAIE,SAAtB;AACA;AACA;;AAEDF,MAAAA,kBAAkB,IAAIJ,KAAK,CAACG,qBAAD,CAA3B;AACAA,MAAAA,qBAAqB,GARtB,CAUC;AACA;AACA;AACA;;AACA,UAAIA,qBAAqB,KAAKH,KAAK,CAACO,MAApC,EACA;AACC;AACA;AACA;AACA,YAAIP,KAAK,CAACO,MAAN,GAAeL,sBAAnB,EACA;AACC;AACA;AACD;AACD;;AAED,QAAIH,mBAAJ,EACA;AACCK,MAAAA,kBAAkB,GAAG,6BAAaA,kBAAb,EAAiCP,QAAjC,CAArB;AACA;;AAED,WAAO;AAAEI,MAAAA,IAAI,EAAEG,kBAAR;AAA4BP,MAAAA,QAAQ,EAARA;AAA5B,KAAP;AACA,GAjDD;AAkDA","sourcesContent":["import { count_occurences } from './helpers'\r\nimport close_braces from './closeBraces'\r\n\r\n// Takes a `template` where character placeholders\r\n// are denoted by 'x'es (e.g. 'x (xxx) xxx-xx-xx').\r\n//\r\n// Returns a function which takes `value` characters\r\n// and returns the `template` filled with those characters.\r\n// If the `template` can only be partially filled\r\n// then it is cut off.\r\n//\r\n// If `should_close_braces` is `true`,\r\n// then it will also make sure all dangling braces are closed,\r\n// e.g. \"8 (8\" -> \"8 (8  )\" (iPhone style phone number input).\r\n//\r\nexport default function(template, placeholder = 'x', should_close_braces)\r\n{\r\n\tif (!template)\r\n\t{\r\n\t\treturn value => ({ text: value })\r\n\t}\r\n\r\n\tconst characters_in_template = count_occurences(placeholder, template)\r\n\r\n\treturn function(value)\r\n\t{\r\n\t\tif (!value)\r\n\t\t{\r\n\t\t\treturn { text: '', template }\r\n\t\t}\r\n\r\n\t\tlet value_character_index = 0\r\n\t\tlet filled_in_template = ''\r\n\r\n\t\t// Using `.split('')` here instead of normal `for ... of`\r\n\t\t// because the importing application doesn't neccessarily include an ES6 polyfill.\r\n\t\t// The `.split('')` approach discards \"exotic\" UTF-8 characters\r\n\t\t// (the ones consisting of four bytes)\r\n\t\t// but template placeholder characters don't fall into that range\r\n\t\t// and appending UTF-8 characters to a string in parts still works.\r\n\t\tfor (const character of template.split(''))\r\n\t\t{\r\n\t\t\tif (character !== placeholder)\r\n\t\t\t{\r\n\t\t\t\tfilled_in_template += character\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tfilled_in_template += value[value_character_index]\r\n\t\t\tvalue_character_index++\r\n\r\n\t\t\t// If the last available value character has been filled in,\r\n\t\t\t// then return the filled in template\r\n\t\t\t// (either trim the right part or retain it,\r\n\t\t\t//  if no more character placeholders in there)\r\n\t\t\tif (value_character_index === value.length)\r\n\t\t\t{\r\n\t\t\t\t// If there are more character placeholders\r\n\t\t\t\t// in the right part of the template\r\n\t\t\t\t// then simply trim it.\r\n\t\t\t\tif (value.length < characters_in_template)\r\n\t\t\t\t{\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (should_close_braces)\r\n\t\t{\r\n\t\t\tfilled_in_template = close_braces(filled_in_template, template)\r\n\t\t}\r\n\r\n\t\treturn { text: filled_in_template, template }\r\n\t}\r\n}"],"file":"templateFormatter.js"}