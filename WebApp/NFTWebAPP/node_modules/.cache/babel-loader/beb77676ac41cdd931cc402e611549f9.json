{"ast":null,"code":"/**\r\n * Prime number generation API.\r\n *\r\n * @author Dave Longley\r\n *\r\n * Copyright (c) 2014 Digital Bazaar, Inc.\r\n */\nvar forge = require('./forge');\n\nrequire('./util');\n\nrequire('./jsbn');\n\nrequire('./random');\n\n(function () {\n  // forge.prime already defined\n  if (forge.prime) {\n    module.exports = forge.prime;\n    return;\n  }\n  /* PRIME API */\n\n\n  var prime = module.exports = forge.prime = forge.prime || {};\n  var BigInteger = forge.jsbn.BigInteger; // primes are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29\n\n  var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];\n  var THIRTY = new BigInteger(null);\n  THIRTY.fromInt(30);\n\n  var op_or = function (x, y) {\n    return x | y;\n  };\n  /**\r\n   * Generates a random probable prime with the given number of bits.\r\n   *\r\n   * Alternative algorithms can be specified by name as a string or as an\r\n   * object with custom options like so:\r\n   *\r\n   * {\r\n   *   name: 'PRIMEINC',\r\n   *   options: {\r\n   *     maxBlockTime: <the maximum amount of time to block the main\r\n   *       thread before allowing I/O other JS to run>,\r\n   *     millerRabinTests: <the number of miller-rabin tests to run>,\r\n   *     workerScript: <the worker script URL>,\r\n   *     workers: <the number of web workers (if supported) to use,\r\n   *       -1 to use estimated cores minus one>.\r\n   *     workLoad: the size of the work load, ie: number of possible prime\r\n   *       numbers for each web worker to check per work assignment,\r\n   *       (default: 100).\r\n   *   }\r\n   * }\r\n   *\r\n   * @param bits the number of bits for the prime number.\r\n   * @param options the options to use.\r\n   *          [algorithm] the algorithm to use (default: 'PRIMEINC').\r\n   *          [prng] a custom crypto-secure pseudo-random number generator to use,\r\n   *            that must define \"getBytesSync\".\r\n   *\r\n   * @return callback(err, num) called once the operation completes.\r\n   */\n\n\n  prime.generateProbablePrime = function (bits, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = options || {}; // default to PRIMEINC algorithm\n\n    var algorithm = options.algorithm || 'PRIMEINC';\n\n    if (typeof algorithm === 'string') {\n      algorithm = {\n        name: algorithm\n      };\n    }\n\n    algorithm.options = algorithm.options || {}; // create prng with api that matches BigInteger secure random\n\n    var prng = options.prng || forge.random;\n    var rng = {\n      // x is an array to fill with bytes\n      nextBytes: function (x) {\n        var b = prng.getBytesSync(x.length);\n\n        for (var i = 0; i < x.length; ++i) {\n          x[i] = b.charCodeAt(i);\n        }\n      }\n    };\n\n    if (algorithm.name === 'PRIMEINC') {\n      return primeincFindPrime(bits, rng, algorithm.options, callback);\n    }\n\n    throw new Error('Invalid prime generation algorithm: ' + algorithm.name);\n  };\n\n  function primeincFindPrime(bits, rng, options, callback) {\n    if ('workers' in options) {\n      return primeincFindPrimeWithWorkers(bits, rng, options, callback);\n    }\n\n    return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);\n  }\n\n  function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {\n    // initialize random number\n    var num = generateRandom(bits, rng);\n    /* Note: All primes are of the form 30k+i for i < 30 and gcd(30, i)=1. The\r\n    number we are given is always aligned at 30k + 1. Each time the number is\r\n    determined not to be prime we add to get to the next 'i', eg: if the number\r\n    was at 30k + 1 we add 6. */\n\n    var deltaIdx = 0; // get required number of MR tests\n\n    var mrTests = getMillerRabinTests(num.bitLength());\n\n    if ('millerRabinTests' in options) {\n      mrTests = options.millerRabinTests;\n    } // find prime nearest to 'num' for maxBlockTime ms\n    // 10 ms gives 5ms of leeway for other calculations before dropping\n    // below 60fps (1000/60 == 16.67), but in reality, the number will\n    // likely be higher due to an 'atomic' big int modPow\n\n\n    var maxBlockTime = 10;\n\n    if ('maxBlockTime' in options) {\n      maxBlockTime = options.maxBlockTime;\n    }\n\n    _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);\n  }\n\n  function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {\n    var start = +new Date();\n\n    do {\n      // overflow, regenerate random number\n      if (num.bitLength() > bits) {\n        num = generateRandom(bits, rng);\n      } // do primality test\n\n\n      if (num.isProbablePrime(mrTests)) {\n        return callback(null, num);\n      } // get next potential prime\n\n\n      num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);\n    } while (maxBlockTime < 0 || +new Date() - start < maxBlockTime); // keep trying later\n\n\n    forge.util.setImmediate(function () {\n      _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);\n    });\n  } // NOTE: This algorithm is indeterminate in nature because workers\n  // run in parallel looking at different segments of numbers. Even if this\n  // algorithm is run twice with the same input from a predictable RNG, it\n  // may produce different outputs.\n\n\n  function primeincFindPrimeWithWorkers(bits, rng, options, callback) {\n    // web workers unavailable\n    if (typeof Worker === 'undefined') {\n      return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);\n    } // initialize random number\n\n\n    var num = generateRandom(bits, rng); // use web workers to generate keys\n\n    var numWorkers = options.workers;\n    var workLoad = options.workLoad || 100;\n    var range = workLoad * 30 / 8;\n    var workerScript = options.workerScript || 'forge/prime.worker.js';\n\n    if (numWorkers === -1) {\n      return forge.util.estimateCores(function (err, cores) {\n        if (err) {\n          // default to 2\n          cores = 2;\n        }\n\n        numWorkers = cores - 1;\n        generate();\n      });\n    }\n\n    generate();\n\n    function generate() {\n      // require at least 1 worker\n      numWorkers = Math.max(1, numWorkers); // TODO: consider optimizing by starting workers outside getPrime() ...\n      // note that in order to clean up they will have to be made internally\n      // asynchronous which may actually be slower\n      // start workers immediately\n\n      var workers = [];\n\n      for (var i = 0; i < numWorkers; ++i) {\n        // FIXME: fix path or use blob URLs\n        workers[i] = new Worker(workerScript);\n      }\n\n      var running = numWorkers; // listen for requests from workers and assign ranges to find prime\n\n      for (var i = 0; i < numWorkers; ++i) {\n        workers[i].addEventListener('message', workerMessage);\n      }\n      /* Note: The distribution of random numbers is unknown. Therefore, each\r\n      web worker is continuously allocated a range of numbers to check for a\r\n      random number until one is found.\r\n        Every 30 numbers will be checked just 8 times, because prime numbers\r\n      have the form:\r\n        30k+i, for i < 30 and gcd(30, i)=1 (there are 8 values of i for this)\r\n        Therefore, if we want a web worker to run N checks before asking for\r\n      a new range of numbers, each range must contain N*30/8 numbers.\r\n        For 100 checks (workLoad), this is a range of 375. */\n\n\n      var found = false;\n\n      function workerMessage(e) {\n        // ignore message, prime already found\n        if (found) {\n          return;\n        }\n\n        --running;\n        var data = e.data;\n\n        if (data.found) {\n          // terminate all workers\n          for (var i = 0; i < workers.length; ++i) {\n            workers[i].terminate();\n          }\n\n          found = true;\n          return callback(null, new BigInteger(data.prime, 16));\n        } // overflow, regenerate random number\n\n\n        if (num.bitLength() > bits) {\n          num = generateRandom(bits, rng);\n        } // assign new range to check\n\n\n        var hex = num.toString(16); // start prime search\n\n        e.target.postMessage({\n          hex: hex,\n          workLoad: workLoad\n        });\n        num.dAddOffset(range, 0);\n      }\n    }\n  }\n  /**\r\n   * Generates a random number using the given number of bits and RNG.\r\n   *\r\n   * @param bits the number of bits for the number.\r\n   * @param rng the random number generator to use.\r\n   *\r\n   * @return the random number.\r\n   */\n\n\n  function generateRandom(bits, rng) {\n    var num = new BigInteger(bits, rng); // force MSB set\n\n    var bits1 = bits - 1;\n\n    if (!num.testBit(bits1)) {\n      num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);\n    } // align number on 30k+1 boundary\n\n\n    num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);\n    return num;\n  }\n  /**\r\n   * Returns the required number of Miller-Rabin tests to generate a\r\n   * prime with an error probability of (1/2)^80.\r\n   *\r\n   * See Handbook of Applied Cryptography Chapter 4, Table 4.4.\r\n   *\r\n   * @param bits the bit size.\r\n   *\r\n   * @return the required number of iterations.\r\n   */\n\n\n  function getMillerRabinTests(bits) {\n    if (bits <= 100) return 27;\n    if (bits <= 150) return 18;\n    if (bits <= 200) return 15;\n    if (bits <= 250) return 12;\n    if (bits <= 300) return 9;\n    if (bits <= 350) return 8;\n    if (bits <= 400) return 7;\n    if (bits <= 500) return 6;\n    if (bits <= 600) return 5;\n    if (bits <= 800) return 4;\n    if (bits <= 1250) return 3;\n    return 2;\n  }\n})();","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/algosigner-react/CIFI/WebApp/NFTWebAPP/node_modules/node-forge/lib/prime.js"],"names":["forge","require","prime","module","exports","BigInteger","jsbn","GCD_30_DELTA","THIRTY","fromInt","op_or","x","y","generateProbablePrime","bits","options","callback","algorithm","name","prng","random","rng","nextBytes","b","getBytesSync","length","i","charCodeAt","primeincFindPrime","Error","primeincFindPrimeWithWorkers","primeincFindPrimeWithoutWorkers","num","generateRandom","deltaIdx","mrTests","getMillerRabinTests","bitLength","millerRabinTests","maxBlockTime","_primeinc","start","Date","isProbablePrime","dAddOffset","util","setImmediate","Worker","numWorkers","workers","workLoad","range","workerScript","estimateCores","err","cores","generate","Math","max","running","addEventListener","workerMessage","found","e","data","terminate","hex","toString","target","postMessage","bits1","testBit","bitwiseTo","ONE","shiftLeft","mod","byteValue"],"mappings":"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","sourcesContent":["/**\r\n * Prime number generation API.\r\n *\r\n * @author Dave Longley\r\n *\r\n * Copyright (c) 2014 Digital Bazaar, Inc.\r\n */\r\nvar forge = require('./forge');\r\nrequire('./util');\r\nrequire('./jsbn');\r\nrequire('./random');\r\n\r\n(function() {\r\n\r\n// forge.prime already defined\r\nif(forge.prime) {\r\n  module.exports = forge.prime;\r\n  return;\r\n}\r\n\r\n/* PRIME API */\r\nvar prime = module.exports = forge.prime = forge.prime || {};\r\n\r\nvar BigInteger = forge.jsbn.BigInteger;\r\n\r\n// primes are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29\r\nvar GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];\r\nvar THIRTY = new BigInteger(null);\r\nTHIRTY.fromInt(30);\r\nvar op_or = function(x, y) {return x|y;};\r\n\r\n/**\r\n * Generates a random probable prime with the given number of bits.\r\n *\r\n * Alternative algorithms can be specified by name as a string or as an\r\n * object with custom options like so:\r\n *\r\n * {\r\n *   name: 'PRIMEINC',\r\n *   options: {\r\n *     maxBlockTime: <the maximum amount of time to block the main\r\n *       thread before allowing I/O other JS to run>,\r\n *     millerRabinTests: <the number of miller-rabin tests to run>,\r\n *     workerScript: <the worker script URL>,\r\n *     workers: <the number of web workers (if supported) to use,\r\n *       -1 to use estimated cores minus one>.\r\n *     workLoad: the size of the work load, ie: number of possible prime\r\n *       numbers for each web worker to check per work assignment,\r\n *       (default: 100).\r\n *   }\r\n * }\r\n *\r\n * @param bits the number of bits for the prime number.\r\n * @param options the options to use.\r\n *          [algorithm] the algorithm to use (default: 'PRIMEINC').\r\n *          [prng] a custom crypto-secure pseudo-random number generator to use,\r\n *            that must define \"getBytesSync\".\r\n *\r\n * @return callback(err, num) called once the operation completes.\r\n */\r\nprime.generateProbablePrime = function(bits, options, callback) {\r\n  if(typeof options === 'function') {\r\n    callback = options;\r\n    options = {};\r\n  }\r\n  options = options || {};\r\n\r\n  // default to PRIMEINC algorithm\r\n  var algorithm = options.algorithm || 'PRIMEINC';\r\n  if(typeof algorithm === 'string') {\r\n    algorithm = {name: algorithm};\r\n  }\r\n  algorithm.options = algorithm.options || {};\r\n\r\n  // create prng with api that matches BigInteger secure random\r\n  var prng = options.prng || forge.random;\r\n  var rng = {\r\n    // x is an array to fill with bytes\r\n    nextBytes: function(x) {\r\n      var b = prng.getBytesSync(x.length);\r\n      for(var i = 0; i < x.length; ++i) {\r\n        x[i] = b.charCodeAt(i);\r\n      }\r\n    }\r\n  };\r\n\r\n  if(algorithm.name === 'PRIMEINC') {\r\n    return primeincFindPrime(bits, rng, algorithm.options, callback);\r\n  }\r\n\r\n  throw new Error('Invalid prime generation algorithm: ' + algorithm.name);\r\n};\r\n\r\nfunction primeincFindPrime(bits, rng, options, callback) {\r\n  if('workers' in options) {\r\n    return primeincFindPrimeWithWorkers(bits, rng, options, callback);\r\n  }\r\n  return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);\r\n}\r\n\r\nfunction primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {\r\n  // initialize random number\r\n  var num = generateRandom(bits, rng);\r\n\r\n  /* Note: All primes are of the form 30k+i for i < 30 and gcd(30, i)=1. The\r\n  number we are given is always aligned at 30k + 1. Each time the number is\r\n  determined not to be prime we add to get to the next 'i', eg: if the number\r\n  was at 30k + 1 we add 6. */\r\n  var deltaIdx = 0;\r\n\r\n  // get required number of MR tests\r\n  var mrTests = getMillerRabinTests(num.bitLength());\r\n  if('millerRabinTests' in options) {\r\n    mrTests = options.millerRabinTests;\r\n  }\r\n\r\n  // find prime nearest to 'num' for maxBlockTime ms\r\n  // 10 ms gives 5ms of leeway for other calculations before dropping\r\n  // below 60fps (1000/60 == 16.67), but in reality, the number will\r\n  // likely be higher due to an 'atomic' big int modPow\r\n  var maxBlockTime = 10;\r\n  if('maxBlockTime' in options) {\r\n    maxBlockTime = options.maxBlockTime;\r\n  }\r\n\r\n  _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);\r\n}\r\n\r\nfunction _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {\r\n  var start = +new Date();\r\n  do {\r\n    // overflow, regenerate random number\r\n    if(num.bitLength() > bits) {\r\n      num = generateRandom(bits, rng);\r\n    }\r\n    // do primality test\r\n    if(num.isProbablePrime(mrTests)) {\r\n      return callback(null, num);\r\n    }\r\n    // get next potential prime\r\n    num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);\r\n  } while(maxBlockTime < 0 || (+new Date() - start < maxBlockTime));\r\n\r\n  // keep trying later\r\n  forge.util.setImmediate(function() {\r\n    _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);\r\n  });\r\n}\r\n\r\n// NOTE: This algorithm is indeterminate in nature because workers\r\n// run in parallel looking at different segments of numbers. Even if this\r\n// algorithm is run twice with the same input from a predictable RNG, it\r\n// may produce different outputs.\r\nfunction primeincFindPrimeWithWorkers(bits, rng, options, callback) {\r\n  // web workers unavailable\r\n  if(typeof Worker === 'undefined') {\r\n    return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);\r\n  }\r\n\r\n  // initialize random number\r\n  var num = generateRandom(bits, rng);\r\n\r\n  // use web workers to generate keys\r\n  var numWorkers = options.workers;\r\n  var workLoad = options.workLoad || 100;\r\n  var range = workLoad * 30 / 8;\r\n  var workerScript = options.workerScript || 'forge/prime.worker.js';\r\n  if(numWorkers === -1) {\r\n    return forge.util.estimateCores(function(err, cores) {\r\n      if(err) {\r\n        // default to 2\r\n        cores = 2;\r\n      }\r\n      numWorkers = cores - 1;\r\n      generate();\r\n    });\r\n  }\r\n  generate();\r\n\r\n  function generate() {\r\n    // require at least 1 worker\r\n    numWorkers = Math.max(1, numWorkers);\r\n\r\n    // TODO: consider optimizing by starting workers outside getPrime() ...\r\n    // note that in order to clean up they will have to be made internally\r\n    // asynchronous which may actually be slower\r\n\r\n    // start workers immediately\r\n    var workers = [];\r\n    for(var i = 0; i < numWorkers; ++i) {\r\n      // FIXME: fix path or use blob URLs\r\n      workers[i] = new Worker(workerScript);\r\n    }\r\n    var running = numWorkers;\r\n\r\n    // listen for requests from workers and assign ranges to find prime\r\n    for(var i = 0; i < numWorkers; ++i) {\r\n      workers[i].addEventListener('message', workerMessage);\r\n    }\r\n\r\n    /* Note: The distribution of random numbers is unknown. Therefore, each\r\n    web worker is continuously allocated a range of numbers to check for a\r\n    random number until one is found.\r\n\r\n    Every 30 numbers will be checked just 8 times, because prime numbers\r\n    have the form:\r\n\r\n    30k+i, for i < 30 and gcd(30, i)=1 (there are 8 values of i for this)\r\n\r\n    Therefore, if we want a web worker to run N checks before asking for\r\n    a new range of numbers, each range must contain N*30/8 numbers.\r\n\r\n    For 100 checks (workLoad), this is a range of 375. */\r\n\r\n    var found = false;\r\n    function workerMessage(e) {\r\n      // ignore message, prime already found\r\n      if(found) {\r\n        return;\r\n      }\r\n\r\n      --running;\r\n      var data = e.data;\r\n      if(data.found) {\r\n        // terminate all workers\r\n        for(var i = 0; i < workers.length; ++i) {\r\n          workers[i].terminate();\r\n        }\r\n        found = true;\r\n        return callback(null, new BigInteger(data.prime, 16));\r\n      }\r\n\r\n      // overflow, regenerate random number\r\n      if(num.bitLength() > bits) {\r\n        num = generateRandom(bits, rng);\r\n      }\r\n\r\n      // assign new range to check\r\n      var hex = num.toString(16);\r\n\r\n      // start prime search\r\n      e.target.postMessage({\r\n        hex: hex,\r\n        workLoad: workLoad\r\n      });\r\n\r\n      num.dAddOffset(range, 0);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Generates a random number using the given number of bits and RNG.\r\n *\r\n * @param bits the number of bits for the number.\r\n * @param rng the random number generator to use.\r\n *\r\n * @return the random number.\r\n */\r\nfunction generateRandom(bits, rng) {\r\n  var num = new BigInteger(bits, rng);\r\n  // force MSB set\r\n  var bits1 = bits - 1;\r\n  if(!num.testBit(bits1)) {\r\n    num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);\r\n  }\r\n  // align number on 30k+1 boundary\r\n  num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);\r\n  return num;\r\n}\r\n\r\n/**\r\n * Returns the required number of Miller-Rabin tests to generate a\r\n * prime with an error probability of (1/2)^80.\r\n *\r\n * See Handbook of Applied Cryptography Chapter 4, Table 4.4.\r\n *\r\n * @param bits the bit size.\r\n *\r\n * @return the required number of iterations.\r\n */\r\nfunction getMillerRabinTests(bits) {\r\n  if(bits <= 100) return 27;\r\n  if(bits <= 150) return 18;\r\n  if(bits <= 200) return 15;\r\n  if(bits <= 250) return 12;\r\n  if(bits <= 300) return 9;\r\n  if(bits <= 350) return 8;\r\n  if(bits <= 400) return 7;\r\n  if(bits <= 500) return 6;\r\n  if(bits <= 600) return 5;\r\n  if(bits <= 800) return 4;\r\n  if(bits <= 1250) return 3;\r\n  return 2;\r\n}\r\n\r\n})();\r\n"]},"metadata":{},"sourceType":"script"}