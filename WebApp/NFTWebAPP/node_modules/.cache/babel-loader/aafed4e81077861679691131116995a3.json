{"ast":null,"code":"/*!\r\n * forwarded\r\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\n'use strict';\n/**\r\n * Module exports.\r\n * @public\r\n */\n\nmodule.exports = forwarded;\n/**\r\n * Get all addresses in the request, using the `X-Forwarded-For` header.\r\n *\r\n * @param {object} req\r\n * @return {array}\r\n * @public\r\n */\n\nfunction forwarded(req) {\n  if (!req) {\n    throw new TypeError('argument req is required');\n  } // simple header parsing\n\n\n  var proxyAddrs = parse(req.headers['x-forwarded-for'] || '');\n  var socketAddr = req.connection.remoteAddress;\n  var addrs = [socketAddr].concat(proxyAddrs); // return all addresses\n\n  return addrs;\n}\n/**\r\n * Parse the X-Forwarded-For header.\r\n *\r\n * @param {string} header\r\n * @private\r\n */\n\n\nfunction parse(header) {\n  var end = header.length;\n  var list = [];\n  var start = header.length; // gather addresses, backwards\n\n  for (var i = header.length - 1; i >= 0; i--) {\n    switch (header.charCodeAt(i)) {\n      case 0x20:\n        /*   */\n        if (start === end) {\n          start = end = i;\n        }\n\n        break;\n\n      case 0x2c:\n        /* , */\n        if (start !== end) {\n          list.push(header.substring(start, end));\n        }\n\n        start = end = i;\n        break;\n\n      default:\n        start = i;\n        break;\n    }\n  } // final address\n\n\n  if (start !== end) {\n    list.push(header.substring(start, end));\n  }\n\n  return list;\n}","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/algosigner-react/CIFI/WebApp/NFTWebAPP/node_modules/forwarded/index.js"],"names":["module","exports","forwarded","req","TypeError","proxyAddrs","parse","headers","socketAddr","connection","remoteAddress","addrs","concat","header","end","length","list","start","i","charCodeAt","push","substring"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;;AAEAA,MAAM,CAACC,OAAP,GAAiBC,SAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,SAAT,CAAoBC,GAApB,EAAyB;AACvB,MAAI,CAACA,GAAL,EAAU;AACR,UAAM,IAAIC,SAAJ,CAAc,0BAAd,CAAN;AACD,GAHsB,CAKvB;;;AACA,MAAIC,UAAU,GAAGC,KAAK,CAACH,GAAG,CAACI,OAAJ,CAAY,iBAAZ,KAAkC,EAAnC,CAAtB;AACA,MAAIC,UAAU,GAAGL,GAAG,CAACM,UAAJ,CAAeC,aAAhC;AACA,MAAIC,KAAK,GAAG,CAACH,UAAD,EAAaI,MAAb,CAAoBP,UAApB,CAAZ,CARuB,CAUvB;;AACA,SAAOM,KAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASL,KAAT,CAAgBO,MAAhB,EAAwB;AACtB,MAAIC,GAAG,GAAGD,MAAM,CAACE,MAAjB;AACA,MAAIC,IAAI,GAAG,EAAX;AACA,MAAIC,KAAK,GAAGJ,MAAM,CAACE,MAAnB,CAHsB,CAKtB;;AACA,OAAK,IAAIG,CAAC,GAAGL,MAAM,CAACE,MAAP,GAAgB,CAA7B,EAAgCG,CAAC,IAAI,CAArC,EAAwCA,CAAC,EAAzC,EAA6C;AAC3C,YAAQL,MAAM,CAACM,UAAP,CAAkBD,CAAlB,CAAR;AACE,WAAK,IAAL;AAAW;AACT,YAAID,KAAK,KAAKH,GAAd,EAAmB;AACjBG,UAAAA,KAAK,GAAGH,GAAG,GAAGI,CAAd;AACD;;AACD;;AACF,WAAK,IAAL;AAAW;AACT,YAAID,KAAK,KAAKH,GAAd,EAAmB;AACjBE,UAAAA,IAAI,CAACI,IAAL,CAAUP,MAAM,CAACQ,SAAP,CAAiBJ,KAAjB,EAAwBH,GAAxB,CAAV;AACD;;AACDG,QAAAA,KAAK,GAAGH,GAAG,GAAGI,CAAd;AACA;;AACF;AACED,QAAAA,KAAK,GAAGC,CAAR;AACA;AAdJ;AAgBD,GAvBqB,CAyBtB;;;AACA,MAAID,KAAK,KAAKH,GAAd,EAAmB;AACjBE,IAAAA,IAAI,CAACI,IAAL,CAAUP,MAAM,CAACQ,SAAP,CAAiBJ,KAAjB,EAAwBH,GAAxB,CAAV;AACD;;AAED,SAAOE,IAAP;AACD","sourcesContent":["/*!\r\n * forwarded\r\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\r\n\r\n'use strict'\r\n\r\n/**\r\n * Module exports.\r\n * @public\r\n */\r\n\r\nmodule.exports = forwarded\r\n\r\n/**\r\n * Get all addresses in the request, using the `X-Forwarded-For` header.\r\n *\r\n * @param {object} req\r\n * @return {array}\r\n * @public\r\n */\r\n\r\nfunction forwarded (req) {\r\n  if (!req) {\r\n    throw new TypeError('argument req is required')\r\n  }\r\n\r\n  // simple header parsing\r\n  var proxyAddrs = parse(req.headers['x-forwarded-for'] || '')\r\n  var socketAddr = req.connection.remoteAddress\r\n  var addrs = [socketAddr].concat(proxyAddrs)\r\n\r\n  // return all addresses\r\n  return addrs\r\n}\r\n\r\n/**\r\n * Parse the X-Forwarded-For header.\r\n *\r\n * @param {string} header\r\n * @private\r\n */\r\n\r\nfunction parse (header) {\r\n  var end = header.length\r\n  var list = []\r\n  var start = header.length\r\n\r\n  // gather addresses, backwards\r\n  for (var i = header.length - 1; i >= 0; i--) {\r\n    switch (header.charCodeAt(i)) {\r\n      case 0x20: /*   */\r\n        if (start === end) {\r\n          start = end = i\r\n        }\r\n        break\r\n      case 0x2c: /* , */\r\n        if (start !== end) {\r\n          list.push(header.substring(start, end))\r\n        }\r\n        start = end = i\r\n        break\r\n      default:\r\n        start = i\r\n        break\r\n    }\r\n  }\r\n\r\n  // final address\r\n  if (start !== end) {\r\n    list.push(header.substring(start, end))\r\n  }\r\n\r\n  return list\r\n}\r\n"]},"metadata":{},"sourceType":"script"}