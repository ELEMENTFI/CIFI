{"ast":null,"code":"// Should be the same as `DIGIT_PLACEHOLDER` in `libphonenumber-metadata-generator`.\nexport var DIGIT_PLACEHOLDER = 'x'; // '\\u2008' (punctuation space)\n\nvar DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER); // Counts all occurences of a symbol in a string.\n// Unicode-unsafe (because using `.split()`).\n\nexport function countOccurences(symbol, string) {\n  var count = 0; // Using `.split('')` to iterate through a string here\n  // to avoid requiring `Symbol.iterator` polyfill.\n  // `.split('')` is generally not safe for Unicode,\n  // but in this particular case for counting brackets it is safe.\n  // for (const character of string)\n\n  for (var _iterator = string.split(''), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var character = _ref;\n\n    if (character === symbol) {\n      count++;\n    }\n  }\n\n  return count;\n} // Repeats a string (or a symbol) N times.\n// http://stackoverflow.com/questions/202605/repeat-string-javascript\n\nexport function repeat(string, times) {\n  if (times < 1) {\n    return '';\n  }\n\n  var result = '';\n\n  while (times > 1) {\n    if (times & 1) {\n      result += string;\n    }\n\n    times >>= 1;\n    string += string;\n  }\n\n  return result + string;\n}\nexport function cutAndStripNonPairedParens(string, cutBeforeIndex) {\n  if (string[cutBeforeIndex] === ')') {\n    cutBeforeIndex++;\n  }\n\n  return stripNonPairedParens(string.slice(0, cutBeforeIndex));\n}\nexport function closeNonPairedParens(template, cut_before) {\n  var retained_template = template.slice(0, cut_before);\n  var opening_braces = countOccurences('(', retained_template);\n  var closing_braces = countOccurences(')', retained_template);\n  var dangling_braces = opening_braces - closing_braces;\n\n  while (dangling_braces > 0 && cut_before < template.length) {\n    if (template[cut_before] === ')') {\n      dangling_braces--;\n    }\n\n    cut_before++;\n  }\n\n  return template.slice(0, cut_before);\n}\nexport function stripNonPairedParens(string) {\n  var dangling_braces = [];\n  var i = 0;\n\n  while (i < string.length) {\n    if (string[i] === '(') {\n      dangling_braces.push(i);\n    } else if (string[i] === ')') {\n      dangling_braces.pop();\n    }\n\n    i++;\n  }\n\n  var start = 0;\n  var cleared_string = '';\n  dangling_braces.push(string.length);\n\n  for (var _i2 = 0, _dangling_braces = dangling_braces; _i2 < _dangling_braces.length; _i2++) {\n    var index = _dangling_braces[_i2];\n    cleared_string += string.slice(start, index);\n    start = index + 1;\n  }\n\n  return cleared_string;\n}\nexport function populateTemplateWithDigits(template, position, digits) {\n  // Using `.split('')` to iterate through a string here\n  // to avoid requiring `Symbol.iterator` polyfill.\n  // `.split('')` is generally not safe for Unicode,\n  // but in this particular case for `digits` it is safe.\n  // for (const digit of digits)\n  for (var _iterator2 = digits.split(''), _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n    var _ref2;\n\n    if (_isArray2) {\n      if (_i3 >= _iterator2.length) break;\n      _ref2 = _iterator2[_i3++];\n    } else {\n      _i3 = _iterator2.next();\n      if (_i3.done) break;\n      _ref2 = _i3.value;\n    }\n\n    var digit = _ref2; // If there is room for more digits in current `template`,\n    // then set the next digit in the `template`,\n    // and return the formatted digits so far.\n    // If more digits are entered than the current format could handle.\n\n    if (template.slice(position + 1).search(DIGIT_PLACEHOLDER_MATCHER) < 0) {\n      return;\n    }\n\n    position = template.search(DIGIT_PLACEHOLDER_MATCHER);\n    template = template.replace(DIGIT_PLACEHOLDER_MATCHER, digit);\n  }\n\n  return [template, position];\n}","map":{"version":3,"sources":["../source/AsYouTypeFormatter.util.js"],"names":["DIGIT_PLACEHOLDER","DIGIT_PLACEHOLDER_MATCHER","count","character","string","times","result","cutBeforeIndex","stripNonPairedParens","retained_template","template","opening_braces","countOccurences","closing_braces","dangling_braces","cut_before","i","start","cleared_string","index","digit","digits","position"],"mappings":"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","sourcesContent":["// Should be the same as `DIGIT_PLACEHOLDER` in `libphonenumber-metadata-generator`.\r\nexport const DIGIT_PLACEHOLDER = 'x' // '\\u2008' (punctuation space)\r\nconst DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER)\r\n\r\n// Counts all occurences of a symbol in a string.\r\n// Unicode-unsafe (because using `.split()`).\r\nexport function countOccurences(symbol, string) {\r\n\tlet count = 0\r\n\t// Using `.split('')` to iterate through a string here\r\n\t// to avoid requiring `Symbol.iterator` polyfill.\r\n\t// `.split('')` is generally not safe for Unicode,\r\n\t// but in this particular case for counting brackets it is safe.\r\n\t// for (const character of string)\r\n\tfor (const character of string.split('')) {\r\n\t\tif (character === symbol) {\r\n\t\t\tcount++\r\n\t\t}\r\n\t}\r\n\treturn count\r\n}\r\n\r\n// Repeats a string (or a symbol) N times.\r\n// http://stackoverflow.com/questions/202605/repeat-string-javascript\r\nexport function repeat(string, times) {\r\n\tif (times < 1) {\r\n\t\treturn ''\r\n\t}\r\n\tlet result = ''\r\n\twhile (times > 1) {\r\n\t\tif (times & 1) {\r\n\t\t\tresult += string\r\n\t\t}\r\n\t\ttimes >>= 1\r\n\t\tstring += string\r\n\t}\r\n\treturn result + string\r\n}\r\n\r\nexport function cutAndStripNonPairedParens(string, cutBeforeIndex) {\r\n\tif (string[cutBeforeIndex] === ')') {\r\n\t\tcutBeforeIndex++\r\n\t}\r\n\treturn stripNonPairedParens(string.slice(0, cutBeforeIndex))\r\n}\r\n\r\nexport function closeNonPairedParens(template, cut_before) {\r\n\tconst retained_template = template.slice(0, cut_before)\r\n\tconst opening_braces = countOccurences('(', retained_template)\r\n\tconst closing_braces = countOccurences(')', retained_template)\r\n\tlet dangling_braces = opening_braces - closing_braces\r\n\twhile (dangling_braces > 0 && cut_before < template.length) {\r\n\t\tif (template[cut_before] === ')') {\r\n\t\t\tdangling_braces--\r\n\t\t}\r\n\t\tcut_before++\r\n\t}\r\n\treturn template.slice(0, cut_before)\r\n}\r\n\r\nexport function stripNonPairedParens(string) {\r\n\tconst dangling_braces =[]\r\n\tlet i = 0\r\n\twhile (i < string.length) {\r\n\t\tif (string[i] === '(') {\r\n\t\t\tdangling_braces.push(i)\r\n\t\t}\r\n\t\telse if (string[i] === ')') {\r\n\t\t\tdangling_braces.pop()\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\tlet start = 0\r\n\tlet cleared_string = ''\r\n\tdangling_braces.push(string.length)\r\n\tfor (const index of dangling_braces) {\r\n\t\tcleared_string += string.slice(start, index)\r\n\t\tstart = index + 1\r\n\t}\r\n\treturn cleared_string\r\n}\r\n\r\nexport function populateTemplateWithDigits(template, position, digits) {\r\n\t// Using `.split('')` to iterate through a string here\r\n\t// to avoid requiring `Symbol.iterator` polyfill.\r\n\t// `.split('')` is generally not safe for Unicode,\r\n\t// but in this particular case for `digits` it is safe.\r\n\t// for (const digit of digits)\r\n\tfor (const digit of digits.split('')) {\r\n\t\t// If there is room for more digits in current `template`,\r\n\t\t// then set the next digit in the `template`,\r\n\t\t// and return the formatted digits so far.\r\n\t\t// If more digits are entered than the current format could handle.\r\n\t\tif (template.slice(position + 1).search(DIGIT_PLACEHOLDER_MATCHER) < 0) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tposition = template.search(DIGIT_PLACEHOLDER_MATCHER)\r\n\t\ttemplate = template.replace(DIGIT_PLACEHOLDER_MATCHER, digit)\r\n\t}\r\n\treturn [template, position]\r\n}"]},"metadata":{},"sourceType":"module"}