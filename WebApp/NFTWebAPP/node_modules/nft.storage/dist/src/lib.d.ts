declare const TokenModel: typeof Token.Token;
/**
 * @implements API.Service
 */
export class NFTStorage implements API.Service {
    /**
     * @hidden
     * @param {string} token
     */
    static auth(token: string): {
        Authorization: string;
    };
    /**
     * @param {API.Service} service
     * @param {Blob} blob
     * @returns {Promise<API.CIDString>}
     */
    static storeBlob({ endpoint, token }: API.Service, blob: Blob): Promise<API.CIDString>;
    /**
     * @param {API.Service} service
     * @param {Blob|API.CarReader} car
     * @param {{onStoredChunk?: (size: number) => void}} [options]
     * @returns {Promise<API.CIDString>}
     */
    static storeCar({ endpoint, token }: API.Service, car: Blob | API.CarReader, { onStoredChunk }?: {
        onStoredChunk?: ((size: number) => void) | undefined;
    } | undefined): Promise<API.CIDString>;
    /**
     * @param {API.Service} service
     * @param {Iterable<File>} files
     * @returns {Promise<API.CIDString>}
     */
    static storeDirectory({ endpoint, token }: API.Service, files: Iterable<File>): Promise<API.CIDString>;
    /**
     * @template {API.TokenInput} T
     * @param {API.Service} service
     * @param {T} metadata
     * @returns {Promise<API.Token<T>>}
     */
    static store<T_2 extends API.TokenInput>({ endpoint, token }: API.Service, metadata: T_2): Promise<API.Token<T_2>>;
    /**
     * @param {API.Service} service
     * @param {string} cid
     * @returns {Promise<API.StatusResult>}
     */
    static status({ endpoint, token }: API.Service, cid: string): Promise<API.StatusResult>;
    /**
     * @param {API.PublicService} service
     * @param {string} cid
     * @returns {Promise<API.CheckResult>}
     */
    static check({ endpoint }: API.PublicService, cid: string): Promise<API.CheckResult>;
    /**
     * @param {API.Service} service
     * @param {string} cid
     * @returns {Promise<void>}
     */
    static delete({ endpoint, token }: API.Service, cid: string): Promise<void>;
    /**
     * Constructs a client bound to the given `options.token` and
     * `options.endpoint`.
     *
     * @example
     * ```js
     * import { NFTStorage, File, Blob } from "nft.storage"
     * const client = new NFTStorage({ token: API_TOKEN })
     *
     * const cid = await client.storeBlob(new Blob(['hello world']))
     * ```
     * Optionally you could pass an alternative API endpoint (e.g. for testing)
     * @example
     * ```js
     * import { NFTStorage } from "nft.storage"
     * const client = new NFTStorage({
     *   token: API_TOKEN
     *   endpoint: new URL('http://localhost:8080/')
     * })
     * ```
     *
     * @param {{token: string, endpoint?:URL}} options
     */
    constructor({ token, endpoint }: {
        token: string;
        endpoint?: URL;
    });
    /**
     * Authorization token.
     *
     * @readonly
     */
    readonly token: string;
    /**
     * Service API endpoint `URL`.
     * @readonly
     */
    readonly endpoint: URL;
    /**
     * Stores a single file and returns the corresponding Content Identifier (CID).
     * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)
     * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File). Note
     * that no file name or file metadata is retained.
     *
     * @example
     * ```js
     * const content = new Blob(['hello world'])
     * const cid = await client.storeBlob(content)
     * cid //> 'Qmf412jQZiuVUtdgnB36FXFX7xg5V6KEbSJ4dpQuhkLyfD'
     * ```
     *
     * @param {Blob} blob
     */
    storeBlob(blob: Blob): Promise<API.CIDString>;
    /**
     * Stores files encoded as a single [Content Addressed Archive
     * (CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).
     *
     * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)
     * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File).
     *
     * Returns the corresponding Content Identifier (CID).
     *
     * See the [`ipfs-car` docs](https://www.npmjs.com/package/ipfs-car) for more
     * details on packing a CAR file.
     *
     * @example
     * ```js
     * import { pack } from 'ipfs-car/pack'
     * import { CarReader } from '@ipld/car'
     * const { out, root } = await pack({
     *  input: fs.createReadStream('pinpie.pdf')
     * })
     * const expectedCid = root.toString()
     * const carReader = await CarReader.fromIterable(out)
     * const cid = await storage.storeCar(carReader)
     * console.assert(cid === expectedCid)
     * ```
     *
     * @example
     * ```
     * import { packToBlob } from 'ipfs-car/pack/blob'
     * const data = 'Hello world'
     * const { root, car } = await packToBlob({ input: [new TextEncoder().encode(data)] })
     * const expectedCid = root.toString()
     * const cid = await client.storeCar(car)
     * console.assert(cid === expectedCid)
     * ```
     * @param {Blob|API.CarReader} car
     * @param {{onStoredChunk?: (size: number) => void}} [options]
     */
    storeCar(car: Blob | API.CarReader, options?: {
        onStoredChunk?: ((size: number) => void) | undefined;
    } | undefined): Promise<API.CIDString>;
    /**
     * Stores a directory of files and returns a CID for the directory.
     *
     * @example
     * ```js
     * const cid = await client.storeDirectory([
     *   new File(['hello world'], 'hello.txt'),
     *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')
     * ])
     * cid //>
     * ```
     *
     * Argument can be a [FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList)
     * instance as well, in which case directory structure will be retained.
     *
     * @param {Iterable<File>} files
     */
    storeDirectory(files: Iterable<File>): Promise<API.CIDString>;
    /**
     * Returns current status of the stored NFT by its CID. Note the NFT must
     * have previously been stored by this account.
     *
     * @example
     * ```js
     * const status = await client.status('Qmf412jQZiuVUtdgnB36FXFX7xg5V6KEbSJ4dpQuhkLyfD')
     * ```
     *
     * @param {string} cid
     */
    status(cid: string): Promise<API.StatusResult>;
    /**
     * Removes stored content by its CID from the service.
     *
     * > Please note that even if content is removed from the service other nodes
     * that have replicated it might still continue providing it.
     *
     * @example
     * ```js
     * await client.delete('Qmf412jQZiuVUtdgnB36FXFX7xg5V6KEbSJ4dpQuhkLyfD')
     * ```
     *
     * @param {string} cid
     */
    delete(cid: string): Promise<void>;
    /**
     * Check if a CID of an NFT is being stored by nft.storage. Throws if the NFT
     * was not found.
     *
     * @example
     * ```js
     * const status = await client.check('Qmf412jQZiuVUtdgnB36FXFX7xg5V6KEbSJ4dpQuhkLyfD')
     * ```
     *
     * @param {string} cid
     */
    check(cid: string): Promise<API.CheckResult>;
    /**
     * Stores the given token and all resources it references (in the form of a
     * File or a Blob) along with a metadata JSON as specificed in
     * [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155#metadata). The
     * `token.image` must be either a `File` or a `Blob` instance, which will be
     * stored and the corresponding content address URL will be saved in the
     * metadata JSON file under `image` field.
     *
     * If `token.properties` contains properties with `File` or `Blob` values,
     * those also get stored and their URLs will be saved in the metadata JSON
     * file in their place.
     *
     * Note: URLs for `File` objects will retain file names e.g. in case of
     * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed
     * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`
     * objects, the URL will not have a file name name or mime type, instead it
     * will be transformed into a URL that looks like
     * `ipfs://bafy...hash/image/blob`.
     *
     * @example
     * ```js
     * const metadata = await client.store({
     *   name: 'nft.storage store test',
     *   description: 'Test ERC-1155 compatible metadata.',
     *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),
     *   properties: {
     *     custom: 'Custom data can appear here, files are auto uploaded.',
     *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),
     *   }
     * })
     *
     * console.log('IPFS URL for the metadata:', metadata.url)
     * console.log('metadata.json contents:\n', metadata.data)
     * console.log('metadata.json with IPFS gateway URLs:\n', metadata.embed())
     * ```
     *
     * @template {API.TokenInput} T
     * @param {T} token
     * @returns {Promise<API.Token<T>>}
     */
    store<T extends API.TokenInput>(token: T): Promise<API.Token<T>>;
}
import { File } from "./platform.js";
import { Blob } from "./platform.js";
import { FormData } from "./platform.js";
import { toGatewayURL } from "./gateway.js";
import * as Token from "./token.js";
import * as API from "./lib/interface.js";
export { TokenModel as Token, File, Blob, FormData, toGatewayURL };
//# sourceMappingURL=lib.d.ts.map